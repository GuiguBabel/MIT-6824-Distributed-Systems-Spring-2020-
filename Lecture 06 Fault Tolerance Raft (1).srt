1
00:00:00,670 --> 00:00:10,490
好吧，让我们今天开始，实际上今天和明天我
all right well let's get started
today and indeed today and tomorrow I'm

2
00:00:10,490 --> 00:00:16,239
我都想谈谈木筏，因为我希望它对您有帮助
gonna talk about raft both because I
hope it'll be helpful you for you in

3
00:00:16,239 --> 00:00:21,650
通过实验室进行植入，还因为您知道这只是一个案例研究
implanting though the labs and also
because you know it's just a case study

4
00:00:21,650 --> 00:00:28,550
在如何使状态机复制正确的细节中， 
in the details of how to get state
machine replication correct so we have

5
00:00:28,550 --> 00:00:33,949
问题的介绍，您可能已经注意到容错模式
introduction to the problem you may have
noticed a pattern in fault-tolerant

6
00:00:33,949 --> 00:00:40,640
到目前为止，我们研究的系统之一是MapReduce复制
systems that we've looked at so far
one is that MapReduce replicates

7
00:00:40,640 --> 00:00:45,949
计算，但复制受控制，整个计算是
computation but the replication is
controlled the whole computation is

8
00:00:45,949 --> 00:00:52,129
由一个大师控制的另一个例子，我想引起您的注意
controlled by a single master another
example I'd like to draw your attention

9
00:00:52,129 --> 00:00:56,780
就是GFS将数据复制为该主备份方案
to is that GFS replicates data right as
this primary backup scheme for

10
00:00:56,780 --> 00:01:01,489
复制文件的实际内容，但它依赖于单个主文件
replicating the actual contents of files
but it relies on a single master to

11
00:01:01,489 --> 00:01:07,909
选择谁是每个数据的主要对象另一个示例vmware ft 
choose who the primary is for every
piece of data another example vmware ft

12
00:01:07,909 --> 00:01:11,840
在主虚拟机和备份上复制计算写操作
replicates computational write on a
primary virtual machine and a backup

13
00:01:11,840 --> 00:01:16,250
虚拟机，但是为了弄清楚下一步是做什么的
virtual machine but in order to figure
out what to do next if one of them seems

14
00:01:16,250 --> 00:01:22,009
如果失败，则依赖于单个测试和设置服务器来帮助选择帮助
to a fail it relies on a single test and
set server to help the choose to help it

15
00:01:22,009 --> 00:01:26,180
如果有一些备份，请确保恰好是备份的主要备份之一
ensure that exactly one of the primary
of the backup takes over if there's some

16
00:01:26,180 --> 00:01:31,820
一种失败，因此在所有这三种情况下都确保存在复制
kind of failure so in all three of these
cases sure there was a replication

17
00:01:31,820 --> 00:01:36,079
系统，但隐藏在复制系统的某个角落
system but sort of tucked away in a
corner in the replication system there

18
00:01:36,079 --> 00:01:40,189
是某些方案，要求单个实体做出关键决策
was some scheme where a single entity
was required to make a critical decision

19
00:01:40,189 --> 00:01:47,210
在我们关心的情况下，谁是主要的
about who the primary was in the cases
we care about so a very nice thing about

20
00:01:47,210 --> 00:01:53,119
由一个实体来决定谁将成为主要实体是因为它不能
having a single entity decide who's
gonna be the primary is that it can't

21
00:01:53,119 --> 00:01:57,619
不同意自己的权利，只有其中一项做出一些决定，那就是
disagree with itself right there's only
one of it makes some decision that's the

22
00:01:57,619 --> 00:02:03,020
做出决定，但由一个实体决定的坏事就像谁
decision it made but the bad thing about
having a single entity decide like who

23
00:02:03,020 --> 00:02:06,590
主要是它本身就是一个单点故障，因此您可以
the primary is is that it itself as a
single point of failure and so you can

24
00:02:06,590 --> 00:02:11,950
查看我们已经查看过的这些系统，这在一定程度上推动了
view these systems that we've looked at
it sort of pushing the real heart of the

25
00:02:11,950 --> 00:02:16,610
容错机械陷入一个小角落
fault tolerance
Machinery into a little corner that is

26
00:02:16,610 --> 00:02:20,719
如果有一个实体，则决定谁将成为主要实体的单一实体
the single entity that decides who's
going to be the primary if there's a

27
00:02:20,719 --> 00:02:25,430
现在失败这整个事情是关于如何避免大脑分裂的原因
failure now this whole thing is about
how to avoid split brain the reason why

28
00:02:25,430 --> 00:02:29,989
我们必须非常谨慎地做出有关
we have to have have to be extremely
careful about making the decision about

29
00:02:29,989 --> 00:02:33,950
如果发生故障，谁应该是主要的，否则我们将面临分裂的风险
who should be the primary if there's a
failure is that otherwise we risks split

30
00:02:33,950 --> 00:02:45,109
大脑，让这一点变得非常清楚，我会提醒您
brain and just make this point super
clear I'm gonna just remind you what the

31
00:02:45,109 --> 00:02:49,989
问题是，为什么它是一个严重的问题，所以假设例如
problem is and why it's a serious
problem so supposing for example where

32
00:02:49,989 --> 00:02:54,409
我们要构建自己的复制测试并设置服务器
we want to build ourselves a replicated
test and set server that is we're

33
00:02:54,409 --> 00:02:58,609
担心vmware ft依赖此测试并将服务器设置为
worried about the fact that vmware ft
relies on this test and set server to

34
00:02:58,609 --> 00:03:02,750
选择主要的是谁，让我们建立一个复制的测试集服务器
choose who the primary is so let's build
a replicated testing set server i'm

35
00:03:02,750 --> 00:03:08,959
要做到这一点，它将被打破，这只是为什么的原因的一个例证
gonna do this it's gonna be broken it's
just an illustration for why why it's

36
00:03:08,959 --> 00:03:12,019
很难得到这个，但是大脑问题正确了，所以你知道我们要
difficult to get this but brain problem
correctly so you know we're gonna

37
00:03:12,019 --> 00:03:18,379
想象我们有一个网络，也许还有两个应该是
imagine we have a network and maybe two
servers which are supposed to be

38
00:03:18,379 --> 00:03:23,180
测试和设置服务的副本已连接，您可能知道两个客户端
replicas of our test and set service
connected and you know maybe two clients

39
00:03:23,180 --> 00:03:26,540
他们需要知道现在谁是主要的，或者实际上可能是这些
they need to know who's the primary
right now or actually maybe these

40
00:03:26,540 --> 00:03:34,669
在这种情况下，客户端是vmware ft中备份的主要对象，因此如果是
clients in this case are the primary in
the back up in vmware ft so if it's a

41
00:03:34,669 --> 00:03:38,120
测试并设置服务，那么您就知道这两个数据库主要是服务器启动的
test and set service then you know both
these databases mostly servers start out

42
00:03:38,120 --> 00:03:42,620
他们的状态即这次试飞的状态归零，并且
with their state that is the state of
this test flight back in zero and the

43
00:03:42,620 --> 00:03:46,250
客户可以发送的一项操作是测试和设置操作，即
one operation their clients can send is
the test and set operation which is

44
00:03:46,250 --> 00:03:52,879
应该将复制服务的标志设置为一个，所以我应该
supposed to set the flag of the
replicated service to one so i should

45
00:03:52,879 --> 00:03:57,500
设置两个副本，然后返回旧值，因此它本质上是一种
set both copies and then return the old
value so it's essentially acts as a kind

46
00:03:57,500 --> 00:04:05,599
简化的锁定服务器还可以，所以问题情况令人担忧
of simplified lock server okay so the
problem situation the lowly worried

47
00:04:05,599 --> 00:04:11,239
当客户端可以与其中一台服务器通信但无法通信时，就会出现关于裂脑的问题
about split-brain arises when a client
can talk to one of the servers but can't

48
00:04:11,239 --> 00:04:14,989
与对方交谈，因此我们在想，当客户发送请求时
talk to the other so we're imagining
either that when clients send a request

49
00:04:14,989 --> 00:04:19,159
他们发送给两个我只是要假设现在，几乎没有
they send it to both I'm just gonna
assume that now and almost doesn't

50
00:04:19,159 --> 00:04:22,190
重要的是，让我们假设协议是客户端应该发送
matter so let's assume that the protocol
is that the clients supposed to send

51
00:04:22,190 --> 00:04:27,260
通常对这两个服务器的任何请求，以及我们知道您需要的某种方式
ordinarily any request to both servers
and somehow we you know we need

52
00:04:27,260 --> 00:04:31,270
想一想如果服务器之一不响应，客户端应该怎么做
think through what the clients should do
if one of the server's doesn't respond

53
00:04:31,270 --> 00:04:34,580
正确或如果其中一台服务器似乎已获得系统应该怎么做
right or what the system should do if
one of the server seems to gotten

54
00:04:34,580 --> 00:04:40,340
快速响应，让我们想象一下，现在客户端可以与服务器之一联系，但是
responsive so let's imagine now the
client one can contact server one but

55
00:04:40,340 --> 00:04:46,520
不是服务器二，系统应该如何应对？一种可能性是因为我们
not server two how should the system
react one possibility is for is that we

56
00:04:46,520 --> 00:04:49,610
想好，你知道，天哪，我们当然不想只跟客户交谈
think well you know gosh we certainly
don't want to just talk to client to

57
00:04:49,610 --> 00:04:53,450
服务器一，因为如果我们进行设置，那将使第二个副本不一致
server one because that would leave the
second replica inconsistent if we set

58
00:04:53,450 --> 00:04:55,820
将此值设为1，但也未将此值设为1 
this value to one but didn't also set
this value to one

59
00:04:55,820 --> 00:04:59,390
所以也许规则应该是总是要求客户与之交谈
so maybe the rule should be that the
client is always required to talk to

60
00:04:59,390 --> 00:05:03,260
将两个副本复制到两个服务器以进行任何操作，并且不应允许
both replicas to both servers for any
operation and shouldn't be allowed to

61
00:05:03,260 --> 00:05:10,820
只是和他们中的一个说话，为什么是错误的答案，所以我们的规则是o 
just talk to one of them so why is that
the wrong answer so the rule is o in our

62
00:05:10,820 --> 00:05:15,290
客户端始终需要与两个副本进行对话的复制系统
replicated system the clients always
require to talk to both replicas in

63
00:05:15,290 --> 00:05:25,490
事实上，要取得进步比和别人说话更糟
order to make progress at all in fact
it's worse it's worse than talking to a

64
00:05:25,490 --> 00:05:30,650
单个服务器，因为如果这些服务器之一是
single server because now the system has
a problem if either of these servers is

65
00:05:30,650 --> 00:05:34,880
崩溃，或者至少无法与非复制服务进行通话
crashed or or you can't talk to it at
least with a non replicated service

66
00:05:34,880 --> 00:05:37,580
您仅依赖一台服务器，但是在这里，我们两台服务器都必须很多
you're only depending on one server but
here we am both servers have to be a lot

67
00:05:37,580 --> 00:05:41,840
如果我们要求客户与两台服务器通话，那么两台服务器必须处于活动状态
if we require the client to talk to both
servers then both servers has to be live

68
00:05:41,840 --> 00:05:46,850
因此我们可能无法要求客户实际上您知道等待两者
so we can't possibly require the client
to actually you know wait for both

69
00:05:46,850 --> 00:05:50,360
服务器要响应，如果我们没有容错能力，我们需要它能够
servers to respond if we don't have
fault tolerance we need it to be able to

70
00:05:50,360 --> 00:05:55,070
继续进行，所以另一个明显的答案是，如果客户不能同时与双方交谈
proceed so another obvious answer is
that if the client can't talk to both

71
00:05:55,070 --> 00:05:59,890
好吧，它只是和一个可以交谈的人交谈，并计算其他人的死亡
well it just talks to the one who can
talk to and figures the other ones dead

72
00:05:59,890 --> 00:06:04,900
所以怎么了，为什么那也不是正确的答案
so what's up why is that also not the
right answer

73
00:06:08,510 --> 00:06:12,110
令人不安的情况是，如果另一台服务器实际上还活着，那么假设
the troubling scenario is if the other
server is actually alive so suppose the

74
00:06:12,110 --> 00:06:16,760
实际的问题或遇到的不是该服务器崩溃了
actual problem or encountering is not
that this server crashed which would be

75
00:06:16,760 --> 00:06:21,500
对我们有好处，但更糟糕的是， 
good for us but the much worse issue
that something went wrong with the

76
00:06:21,500 --> 00:06:26,210
网络电缆，并且该客户端可以通话爬网，可以与服务器通话
network cable and that this client can
talk to climb one can talk to server one

77
00:06:26,210 --> 00:06:29,600
但不是第二台服务器，可能还有其他一些客户端
but not server two and there's maybe
some other client out there that conduct

78
00:06:29,600 --> 00:06:35,600
服务器二而不是服务器一，所以如果我们制定一个规则，即客户可以通话
a server two but not server one so if we
make the rule that if a client can talk

79
00:06:35,600 --> 00:06:39,680
对两台服务器来说都可以，以便可以容错。 
to both servers that it's okay in order
to be fault tolerant that I just talked

80
00:06:39,680 --> 00:06:46,130
然后一个人不可避免地会发生什么事，说这根电缆会断线
to one then what's just inevitably gonna
happen said this cable is gonna break

81
00:06:46,130 --> 00:06:51,320
从而将网络减少一半，一个客户端将发送测试并设置请求
thus cutting the network in half client
one is gonna send a test and set request

82
00:06:51,320 --> 00:06:56,270
服务器一台服务器，您会知道将其状态设置为一并返回
to server one server one will you know
set it state to one and return the

83
00:06:56,270 --> 00:06:59,660
客户1的先前值为零，这意味着客户妈妈会认为
previous value of zero to client one and
so that mean client mom will think it

84
00:06:59,660 --> 00:07:04,310
有锁，如果是VMware ft服务器，它将认为这可能是接管
has the lock and if it's a VMware ft
server will think it can be takeovers

85
00:07:04,310 --> 00:07:08,570
主要但此副本仍为零，现在如果客户要
primarily but this replica still of zero
in it all right so now if client to

86
00:07:08,570 --> 00:07:12,920
谁还会发送测试和设置请求给您，您会知道将其发送给什么价格
who've also sends a test and set request
to you know what price to send them to

87
00:07:12,920 --> 00:07:16,820
都看到服务器一台似乎已关闭，这遵循的原则是您
both sees that server one appears to be
down follows the rule that says well you

88
00:07:16,820 --> 00:07:22,460
只是发送到一台服务器，但您可以与之交谈，它也会认为它
just send to the one server but you can
talk to then it will also think that it

89
00:07:22,460 --> 00:07:25,520
要么安静，因为客户端，您也认为它获得了锁， 
would either quiet because client you
also think that it acquired the lock and

90
00:07:25,520 --> 00:07:28,820
所以现在您知道我们是否正在构想该测试，并且该服务器将
so now you know if we were imagining
this test and that server was going to

91
00:07:28,820 --> 00:07:35,020
与和一起使用时，我们并没有同时复制这两个VMware 
be used with the and where ft we have
not both replicas both of these VMware

92
00:07:35,020 --> 00:07:41,180
我认为这些机器本身可以是主要的，而无需咨询
machines I think they could be primary
by themselves without consulting the

93
00:07:41,180 --> 00:07:45,350
其他服务器，这是一个完全失败，因此通过此设置和两个
other server so that's a complete
failure so with this set up and two

94
00:07:45,350 --> 00:07:49,700
服务器似乎我们有这个，我们只需要选择要么等待
servers it seemed like we had this we
just had to choose either you wait for

95
00:07:49,700 --> 00:07:54,440
两者都不能容错，或者您只等一个而又不容错
both and you're not fault-tolerant or
you wait for just one and you're not

96
00:07:54,440 --> 00:07:59,560
正确，然后是我们的正确版本，通常称为裂脑
correct and then our correct version
it's often called split brain so

97
00:07:59,560 --> 00:08:06,940
大家都很好看
everybody see this well

98
00:08:09,129 --> 00:08:16,520
所以这基本上是直到80年代后期，人们
so this was basically where things stood
until the late 80s and when people but

99
00:08:16,520 --> 00:08:20,509
人们确实想构建您知道的复制系统，例如那些
people did want to build replicated
systems you know like the computers that

100
00:08:20,509 --> 00:08:24,919
控制电话交换机或运行银行的计算机
control telephone switches or the
computers that ran banks you know there

101
00:08:24,919 --> 00:08:27,830
当我们花费大量金钱来获得可靠
was placer when we spend a huge amount
of money in order to have reliable

102
00:08:27,830 --> 00:08:31,219
服务，因此他们将进行复制，以构建复制的系统，并且
service and so they would replicate they
would build replicated systems and the

103
00:08:31,219 --> 00:08:35,240
他们会处理的方式，然后他们会复制但尝试
way they would deal then way would that
they would have replication but try to

104
00:08:35,240 --> 00:08:41,089
排除大脑裂开这是两种技术，一种是
rule out of rule out split brain it's a
couple of techniques one is they would

105
00:08:41,089 --> 00:08:47,360
建立一个不会失败的网络，通常这意味着什么，实际上
build a network that could not fail and
so usually what that means and in fact

106
00:08:47,360 --> 00:08:51,259
你们使用的网络基本上不会在所有时间中断
you guys use networks that essentially
cannot fail all the time the wires

107
00:08:51,259 --> 00:08:57,589
在笔记本电脑内部，您知道将CPU连接到DRAM的确有效
inside your laptop you know connecting
the CPU to the DRAM are effectively what

108
00:08:57,589 --> 00:09:02,930
您知道在CPU和DRAM之间不会出现故障的网络，因此
you know a network that cannot fail
between the between your CPU and DRAM so

109
00:09:02,930 --> 00:09:07,310
你知道合理的假设和很多钱，你知道
you know with reasonable assumptions and
lots of money and you know sort of

110
00:09:07,310 --> 00:09:11,180
精心控制的身体状况，例如您不需要电缆
carefully controlled physical situation
like you don't want to have a cable

111
00:09:11,180 --> 00:09:15,040
在地板上偷偷摸摸地有人可以踩到你知道这一定是
snaking across the floor that somebody
can step on you know it's got to be

112
00:09:15,040 --> 00:09:19,759
物理设计的网络可以确保您不会失败
physically designed set up with a
network that cannot fail you can rule

113
00:09:19,759 --> 00:09:22,939
分裂大脑这是一个假设，但有足够的钱人
out split brain it's bit of an
assumption but with enough money people

114
00:09:22,939 --> 00:09:27,050
非常接近这一点，因为如果网络无法失败，则基本上意味着
get quite close to this because if the
network cannot fail that basically means

115
00:09:27,050 --> 00:09:31,310
客户端无法与服务器对话，这意味着第二台服务器必须停机
that the client can't talk to a server
to that means server two must be down

116
00:09:31,310 --> 00:09:35,449
因为它不可能是网络故障，所以这是一种方法
because it can't have been the network
malfunctioning so that was one way that

117
00:09:35,449 --> 00:09:41,949
人们构建了不会遭受脑裂的复制系统
people sort of built replication systems
it didn't suffer from split brain

118
00:09:42,009 --> 00:09:46,130
另一种可能性是让一些人来解决问题
another possibility would be to have
some human beings sort out the problem

119
00:09:46,130 --> 00:09:49,970
那是不会自动做任何事情，而是让您认识的客户
that is don't automatically do anything
instead have the clients you know by

120
00:09:49,970 --> 00:09:54,110
默认客户端始终必须等待您知道两个副本都响应或
default clients always have to wait for
you know both replicas to respond or

121
00:09:54,110 --> 00:09:58,519
某些事情永远不允许继续进行，但你可以知道
something never allowed to proceed with
just one of them but you can you know

122
00:09:58,519 --> 00:10:02,540
叫某人的哔哔声离开某人去机房， 
call somebody's beeper to go off some
human being goes to the machine room and

123
00:10:02,540 --> 00:10:07,009
看起来两个副本，然后关闭其中一个以确保它是
sort of looks at the two replicas and
either turns one off to make sure it's

124
00:10:07,009 --> 00:10:10,130
肯定已经死亡或验证其中一个确实存在
definitely dead
or verifies that one of them has indeed

125
00:10:10,130 --> 00:10:14,990
坠毁，如果另一个还活着，那么您实际上是在使用人类作为
crashed and if the other is alive and so
you're essentially using the human as a

126
00:10:14,990 --> 00:10:20,750
因为抢七局和人是一个人，你知道他们是否是计算机
as the tie breaker and the human is a
you know if they were a computer it

127
00:10:20,750 --> 00:10:25,670
如果您自己如此，那么很长一段时间人们都会使用
would be a single point if you
themselves so for a long time people use

128
00:10:25,670 --> 00:10:28,970
这些方案之一是为了构建复制系统， 
one of the other these schemes in order
to build replicated systems and it's not

129
00:10:28,970 --> 00:10:32,480
你知道他们可以被创造出来，人类不会很快做出反应， 
you know they can be made to work the
humans don't respond very quickly and

130
00:10:32,480 --> 00:10:38,869
无法失败的网络是昂贵的，但并非不可能，但是它
the network that cannot fail is
expensive but it's not not doable but it

131
00:10:38,869 --> 00:10:45,949
事实证明，您实际上可以构建可以正常工作的自动故障转移系统
turned out that you can actually build
automated failover systems that can work

132
00:10:45,949 --> 00:10:51,290
面对易碎的网络可能会失败
correctly in the face of flaky networks
of networks that could fail on the can

133
00:10:51,290 --> 00:10:54,920
进行分区，以便将网络分成两半，由双方共同操作
partition so this split of the network
in half where the two sides operate they

134
00:10:54,920 --> 00:11:04,910
不能互相交谈，通常被称为分区，而洞察力很大
can't talk to each other that's usually
called a partition and the big insight

135
00:11:04,910 --> 00:11:10,100
人们想出了建立自动复制系统
that people came up with in order to
build automated replication systems that

136
00:11:10,100 --> 00:11:17,649
不要遭受脑裂的困扰，这是多数表决的想法
don't suffer from split brain is the
idea of a majority vote this is a

137
00:11:20,079 --> 00:11:24,110
几乎在筏子中像其他句子一样出现的概念
concept that shows up in like every
other sentence practically in the raft

138
00:11:24,110 --> 00:11:31,459
进行第一步的基本方法是
paper sort of fundamental way of
proceeding the first step is to have an

139
00:11:31,459 --> 00:11:35,779
服务器的数量是奇数，而不是偶数，例如一个缺陷是
odd number of servers instead of an even
number of servers like one flaw here is

140
00:11:35,779 --> 00:11:39,379
在这里分割的两侧有点太对称了
that it's a little bit too symmetric all
right the two sides of the split here

141
00:11:39,379 --> 00:11:42,589
只是它们看起来一样所以他们运行相同的软件
just they just look the same so they run
the same software they're gonna do the

142
00:11:42,589 --> 00:11:47,439
同样的事情，那不是很好，但是如果您的服务器数量奇数，那么
same thing and that's not good but if
you have an odd number of servers then

143
00:11:47,439 --> 00:11:52,939
它不再是对称的，至少会有一个网络分裂
it's not symmetric anymore right at
least a single network split will be

144
00:11:52,939 --> 00:11:56,179
大概一侧有两台服务器，另一侧有一台服务器，它们
presumably two servers on one side and
one server on the other side and they

145
00:11:56,179 --> 00:12:00,829
完全不会对称，这是多数投票多数的一部分
won't be symmetric at all and that's
part of what majority vote majority

146
00:12:00,829 --> 00:12:05,629
投票方案吸引了如此基本的想法，因此您拥有数量奇数的服务器
voting schemes are appealing to so basic
ideas you have an odd number of servers

147
00:12:05,629 --> 00:12:10,939
为了取得任何进展，因此在筏子中选出一个领导者或引起一个日志
in order to make progress of any kind so
in raft elect a leader or cause a log

148
00:12:10,939 --> 00:12:15,379
为了在每个步骤上取得任何进展而必须提交的条目
entry to be committed in order to make
any progress at each step you have to

149
00:12:15,379 --> 00:12:20,149
将一半以上的服务器组装成一半以上的服务器
assemble a majority of the server's more
than half more than half of all the

150
00:12:20,149 --> 00:12:25,279
服务器以批准该步骤，例如投票要求开会或接受
servers in order to sort of approve that
step like vote for a meet or accept a

151
00:12:25,279 --> 00:12:32,749
新的日志条目并将其提交，因此您知道最直接的方法是两个
new log entry and commit it so you know
the most straightforward way is that two

152
00:12:32,749 --> 00:12:36,669
或三台服务器需要执行任何操作
or three servers required to do anything

153
00:12:37,819 --> 00:12:43,499
当然有效的原因之一是，如果有分区，就不会有分区
one reason this works of course is that
if there's a partition there can't be

154
00:12:43,499 --> 00:12:47,639
一个以上具有大部分服务器分区的分区是一种方法
more than one partition with a majority
of the server's in it that's one way to

155
00:12:47,639 --> 00:12:53,009
看看这个分区中可以有一个服务器，但它不是大多数
look at this a partition can have one
server in it which it's not a majority

156
00:12:53,009 --> 00:12:56,550
或者也许可以有两个，但是如果一个分区有两个，那么另一个分区
or maybe you can have two but if one
partition has two then the other

157
00:12:56,550 --> 00:13:00,689
分区中只能有一个服务器，因此永远无法
partition has to have only one server in
it and therefore will never be able to

158
00:13:00,689 --> 00:13:07,350
聚集多数，将无法取得进展，只能完全
assemble a majority and won't be able to
make progress and just to be totally

159
00:13:07,350 --> 00:13:11,610
很清楚，当我们谈论多数时，总是占多数
clear when we're talking about a
majority it's always a majority out of

160
00:13:11,610 --> 00:13:15,930
所有服务器不仅是实时服务器，这是令人困惑的一点
all of the server's not just a live
servers this is the point that confused

161
00:13:15,930 --> 00:13:19,259
我很长一段时间，但如果您的系统具有三台服务器，也许还有一些
me for a long time but if you have a
system with three servers and maybe some

162
00:13:19,259 --> 00:13:22,259
他们中的一些失败了，或者如果您需要大多数组装的话， 
of them have failed or something if you
need to assemble in the majority it's

163
00:13:22,259 --> 00:13:26,309
即使您知道一个失败了，也总是三分之二
always two out of three even if you know
that one has failed the majority is

164
00:13:26,309 --> 00:13:30,420
总是在服务器总数中有一个更一般的
always out of the total number of
servers there's a more general

165
00:13:30,420 --> 00:13:35,610
之所以这样表述，是因为多数票制中三分之二
formulation of this because a majority
voting system in which two out of three

166
00:13:35,610 --> 00:13:40,889
需要取得进展，使其可以在一台服务器的故障中幸存下来
are required to make progress it can
survive the failure of one server right

167
00:13:40,889 --> 00:13:45,180
如果需要的话，任何两台服务器足以使进度
any two servers are enough to make
progress if you need to be able to if

168
00:13:45,180 --> 00:13:49,980
您知道自己担心服务器的可靠性，然后
you're you know you worried about how
reliable your servers are or then you

169
00:13:49,980 --> 00:13:53,490
可以构建具有更多服务器的系统，因此更一般的表述是
can build systems that have more servers
and so the more general formulation is

170
00:13:53,490 --> 00:14:06,930
如果您有两个F +1服务器，那么您可以承受，所以如果是三个
if you have two F + 1 servers then you
can withstand you know so if it's three

171
00:14:06,930 --> 00:14:12,809
这意味着F是一个，而具有三个服务器的系统可以容忍F个服务器
that means F is one and the system with
three servers you can tolerate F servers

172
00:14:12,809 --> 00:14:17,449
第一步失败，仍然继续
step one failure and still keep going

173
00:14:19,769 --> 00:14:25,350
好吧，这些通常称为仲裁系统，因为三分之二是
all right often these are called quorum
systems because the two out of three is

174
00:14:25,350 --> 00:14:30,519
有时举行法定人数，所以我已经提到过一个物业
sometimes held a quorum okay so one
property I've already mentioned about

175
00:14:30,519 --> 00:14:36,759
这些多数表决系统是，最多一个分区可以拥有多数
these majority voting systems is that at
most one partition can have a majority

176
00:14:36,759 --> 00:14:40,569
因此，如果网络分区了，我们就不能同时拥有一半
and therefore if the networks
partitioned we can't have both halves of

177
00:14:40,569 --> 00:14:44,499
网络使进步的另一个更微妙的事情是
the network making progress another more
subtle thing that's going on here is

178
00:14:44,499 --> 00:14:52,629
如果您始终需要大多数服务器才能继续
that if you always need a majority of
the servers to proceed and you go

179
00:14:52,629 --> 00:14:55,990
通过一系列连续的操作，其中到达操作
through a sort of succession of
operations in which reach operations

180
00:14:55,990 --> 00:15:00,730
有人聚集了多数席位，就像您知道领导人的选票，还是说
somebody assembled a majority like you
know votes for leaders or let's say

181
00:15:00,730 --> 00:15:06,519
领导人的选票到了，然后在每一步中，您为此聚集的多数
votes for leaders arrived then at every
step the majority you assemble for that

182
00:15:06,519 --> 00:15:11,290
步骤必须包含至少一台以前占多数的服务器
step must contain at least one server
that was in the previous majority that

183
00:15:11,290 --> 00:15:17,800
至少一台服务器中有两个多数是重叠的，实际上
is any two majorities overlap in at
least one server and it's really that

184
00:15:17,800 --> 00:15:25,059
财产比筏子赖以避免大脑分裂的其他任何东西都重要
property more than anything else that
raft is relying on to avoid split brain

185
00:15:25,059 --> 00:15:28,480
这是事实，例如，当你有一个领导者时，一个成功的领导者
it's the fact that for example when you
have a leader a successful leader

186
00:15:28,480 --> 00:15:32,980
选举和领导人从多数票中选出，保证多数票通过
election and leader assembles votes from
a majority its majority is guaranteed to

187
00:15:32,980 --> 00:15:36,490
与以前的领导人多数重叠，例如新的
overlap with the previous leaders
majority and so for example the new

188
00:15:36,490 --> 00:15:41,279
保证领导者知道前任领导者使用的任期编号
leader is guaranteed to know about the
term number used by the previous leader

189
00:15:41,279 --> 00:15:45,299
因为它的多数派与之前的领导人多数派重叠，并且
because it's a majority overlaps with
the previous leaders majority and

190
00:15:45,299 --> 00:15:49,059
历届领导人中的大多数人都知道历届领导人
everybody in the previous leaders
majority knew about the previous leaders

191
00:15:49,059 --> 00:15:53,019
任期编号与前任领导者相似
term number
similarly anything the previous leader

192
00:15:53,019 --> 00:15:57,970
本可以提交的必须存在于筏中的大多数服务器中，并且
could have committed must be present in
a majority of the servers in raft and

193
00:15:57,970 --> 00:16:01,869
因此，任何新的领导者多数都必须至少与一台服务器重叠
therefore any new leaders majority must
overlap at at least one server with

194
00:16:01,869 --> 00:16:08,529
前任领导人的每一项承诺承诺，都是其重要原因
every committed entry from the previous
leader this is a big part of why it is

195
00:16:08,529 --> 00:16:13,110
包裹是正确的
that wrapped is correct

196
00:16:14,440 --> 00:16:22,860
有关多数投票制一般概念的任何疑问
any questions about the general concept
of majority voting systems

197
00:16:27,940 --> 00:16:31,470
这些肌肉广告服务器
these muscle ad servers

198
00:16:31,760 --> 00:16:36,710
这可能是相交的东西，也许论文中的六个解释了如何
it's possible intersection something
maybe six in the paper explains how to

199
00:16:36,710 --> 00:16:44,600
添加它或更改服务器集，可能您需要在一个
add it or change the set of servers and
it's possible you need to do it in a

200
00:16:44,600 --> 00:16:48,800
长时间运行的系统，如果您将系统运行五十年，您就会知道
long-running system if you're running
your system for five ten years you know

201
00:16:48,800 --> 00:16:52,490
一段时间后，您将需要更换服务器
you're gonna need to replace the servers
after a while you know one of them fails

202
00:16:52,490 --> 00:16:56,390
永久性或升级或将机房移至其他计算机
permanently or you upgrade or you move
machine rooms to a different machine

203
00:16:56,390 --> 00:17:00,200
您真正需要的机房必须能够支持不断变化的服务器组，因此
room you really do need to be able to
support changing sets of servers so

204
00:17:00,200 --> 00:17:03,230
那当然不是每天都会发生，但这是
that's a it certainly doesn't happen
every day but it's a critical part of

205
00:17:03,230 --> 00:17:08,480
这些系统的长期或可维护性，您知道英国皇家空军
this or a long-term maintainability of
these systems and you know the RAF

206
00:17:08,480 --> 00:17:13,099
作者有点自以为是，他们有一个解决方案
authors sort of pat themselves on the
back that they have a scheme that deals

207
00:17:13,099 --> 00:17:21,859
他们也可能这样做，因为它很复杂，所以使用
with this which as well they might
because it's complex all right so using

208
00:17:21,859 --> 00:17:28,039
这个想法在大约1990年左右提出了两个大致相同的系统

209
00:17:28,040 --> 00:17:34,210
意识到您可以使用多数投票制的时间
time that realized that you could use
this majority voting system to kind of

210
00:17:34,210 --> 00:17:41,150
基本上避免使用避免大脑分裂的明显不可能
get around the apparent impossibility of
avoiding split brain by using basically

211
00:17:41,150 --> 00:17:46,520
通过使用三台服务器（而不是两台）并获得多数票，并在其中一台
by using three servers instead of two
and taking majority votes and in one of

212
00:17:46,520 --> 00:17:51,860
这些非常早期的系统被称为Paxos，英国皇家空军的论文谈到了
these very early systems was called
Paxos the RAF paper talks about this a

213
00:17:51,860 --> 00:17:56,420
这些早期系统中的另一个被称为视图图章
lot and another of these very early
systems was called view stamp

214
00:17:56,420 --> 00:18:02,840
复制previa des vs r4视图戳复制，即使Paxos 
replication a previa des vs r4 view
stamp replication and even though Paxos

215
00:18:02,840 --> 00:18:07,310
到目前为止，pod是该部门筏中最广泛使用的系统
pod is by far the more widely known
system in this department raft is

216
00:18:07,310 --> 00:18:11,650
实际上在设计上更接近设计以查看陈述，很少使用图章
actually closer to design in design to
view statment few stamp application

217
00:18:11,650 --> 00:18:19,280
这是麻省理工学院的人发明的，所以十年来有种法律
which was invented by people at MIT and
so there's a sort of a law many decade

218
00:18:19,280 --> 00:18:24,800
这些系统的历史，它们才真正走到最前沿并开始
history of these systems and they only
really came to the forefront and started

219
00:18:24,800 --> 00:18:29,270
被部署在大型分布式sisty系统中使用了大约15年
being used a lot in deployed big
distributed sisty systems about 15 years

220
00:18:29,270 --> 00:18:39,680
早在最初发明它们的15年后，好吧，让我谈谈
ago a good 15 years after they were
originally invented okay so let me talk

221
00:18:39,680 --> 00:18:42,340
关于拉丝
about Rath now

222
00:18:42,770 --> 00:18:49,049
筏是一种旨在包含在某些服务中的图书馆形式
raft is a takes the form of a library
intended to be included in some service

223
00:18:49,049 --> 00:18:53,580
应用程序，因此，如果您具有复制服务，则
application so if you have a replicated
service that each of the replicas in the

224
00:18:53,580 --> 00:18:57,150
服务将是一些您知道会收到rpcs的应用程序代码，或者
service is gonna be some application
code which you know receives rpcs or

225
00:18:57,150 --> 00:19:01,740
东西加上一个筏库，并且筏库相互协作
something plus a raft library and the
raft libraries cooperate with each other

226
00:19:01,740 --> 00:19:10,260
意味着复制可保持复制，因此单个软件的软件概述
to mean replication maintain replication
so sort of software overview of a single

227
00:19:10,260 --> 00:19:15,539
筏副本是在顶部，我们可以想到具有
raft replica is that at the top we can
think of the replicas having the

228
00:19:15,539 --> 00:19:20,789
应用程序代码，因此它可能是针对实验3的键值服务器，所以也许
application code so it might be for lab
3 a key-value server so maybe we have

229
00:19:20,789 --> 00:19:26,880
一些键值服务器，并且在某种状态下，应用程序具有以下状态： 
some key value server and in a state the
application has state that raft is

230
00:19:26,880 --> 00:19:30,299
帮助它管理复制状态，对于键值服务器，它将是
helping it manage replicated state and
for a key value server it's going to be

231
00:19:30,299 --> 00:19:44,340
键和值的表，下一层是筏层，因此键
a table of keys and values the next
layer down is a raft layer so the key

232
00:19:44,340 --> 00:19:47,760
价值服务器会在筏中进行make函数调用， 
value server is gonna sort of make
function calls into raft and they're

233
00:19:47,760 --> 00:19:52,070
会来回itch，筏子保持一点状态
gonna chitchat back and forth a little
bit and raft keeps a little bit of state

234
00:19:52,070 --> 00:19:56,280
您可以在图2中看到它，对于我们来说，这实际上是最关键的部分
you can see it in Figure 2 and for our
purposes really the most critical piece

235
00:19:56,280 --> 00:20:08,370
状态是筏有操作日志和3次呼吸的系统
of state is that raft has a log of
operations and a system with 3 breath

236
00:20:08,370 --> 00:20:12,030
会导致我们实际上要让您知道3台服务器
will cause we're actually gonna have you
know 3 servers that have exactly the

237
00:20:12,030 --> 00:20:19,950
相同的结构，希望坐在相同的数据
same identical structure and hopefully
the very same data sitting in sitting at

238
00:20:19,950 --> 00:20:22,370
两层
both layers

239
00:20:32,380 --> 00:20:38,870
除此之外，会有客户，而游戏就是这样
right outside of this there's gonna be
clients and the game is that so we have

240
00:20:38,870 --> 00:20:42,769
你知道客户1和客户两个客户群
you know client 1 and client two whole
bunch of clients the clients don't

241
00:20:42,769 --> 00:20:46,789
真正了解客户，您只知道需要
really know the clients are you know
just external code that needs to be able

242
00:20:46,789 --> 00:20:50,960
使用服务，希望的是客户真的不需要知道
to use the service and the hope is the
clients won't really need to be aware

243
00:20:50,960 --> 00:20:53,690
他们正在与复制服务进行通信，该复制服务与
that they're talking to a replicated
service that to the clients that are

244
00:20:53,690 --> 00:20:59,029
看起来几乎就像一台服务器，而他们与一台服务器通信，因此
looking almost like it's just one server
and they talked with one server and so

245
00:20:59,029 --> 00:21:04,220
客户端实际上将客户端请求发送给应用程序的密钥
the clients actually send client
requests to the key to the application

246
00:21:04,220 --> 00:21:11,720
当前领导者的图层是筏中当前领导者的副本，因此
layer of the current leader the replica
that's the current leader in raft and so

247
00:21:11,720 --> 00:21:15,740
这些将成为您知道密钥的数据库的应用程序级别请求
these are gonna be you know application
level requests for a database for a key

248
00:21:15,740 --> 00:21:20,570
值服务器，这些服务器可能放在获取请求中，而您知道该请求需要一个密钥和
value server these might be put in get
requests you know put takes a key and a

249
00:21:20,570 --> 00:21:29,529
值并更新表，并要求服务获取当前密钥
value and updates the table and get
asked the service to get the current key

250
00:21:29,529 --> 00:21:36,080
对应于某个键的当前值，所以这样就无关紧要
current value corresponding to some key
so this like has nothing about to do

251
00:21:36,080 --> 00:21:38,510
用木筏不管是什么，都只是客户端-服务器交互的一种
with raft it's just sort of
client-server interaction for whatever

252
00:21:38,510 --> 00:21:43,580
我们正在构建的服务，但是一旦其中一个命令从
service we're building but once one of
these commands gets sent from the

253
00:21:43,580 --> 00:21:48,289
请求是从服务器的客户端发送的，实际发生的是您
requests get sent from the clients of
the server what actually happens is you

254
00:21:48,289 --> 00:21:53,000
知道在非复制服务器上应用程序代码想要执行此操作
know on a non replicated server the
application code would like execute this

255
00:21:53,000 --> 00:21:56,690
请求并说更新表格并回复书，但不在木筏中
request and say update the table and
response to a book but not in a raft

256
00:21:56,690 --> 00:22:00,740
如果假设客户端向领导发送请求，则复制服务
replicated service instead if assuming
the client sends a request to leader

257
00:22:00,740 --> 00:22:06,559
真正发生的是应用层只是发送请求
what really happens is the application
layer simply sends the request the

258
00:22:06,559 --> 00:22:09,909
客户要求到木筏层说看起来你知道这是一个请求
clients request down into the raft layer
to say look you know here's a request

259
00:22:09,909 --> 00:22:15,440
请把它提交到复制的日志中，并告诉我何时
please get it committed into the
replicated log and tell me when you're

260
00:22:15,440 --> 00:22:23,840
完成，所以在这一点上，木筏彼此缩，直到所有
done and so at this point the rafts
chitchat with each other until all the

261
00:22:23,840 --> 00:22:29,000
副本占多数，副本将此新操作放入其日志中
replicas are a majority the replicas get
this new operation into their logs said

262
00:22:29,000 --> 00:22:34,909
它被复制，然后当其领导者知道所有的副本
it is replicated and then when its
leader knows that all of the replicas of

263
00:22:34,909 --> 00:22:40,340
仅当木筏向该钥匙发送备份通知时，才将此副本
a copy of this only then as a raft sent
a notification up back up to the key

264
00:22:40,340 --> 00:22:44,389
珍惜他们在说啊哈，你发给我的手术我的意思是
value they are saying aha that operation
you sent me I mean

265
00:22:44,389 --> 00:22:49,309
现在已将其提交到所有副本中，因此可以安全地复制
it's been now committed into all the
replicas and so it's safely replicated

266
00:22:49,309 --> 00:22:55,089
此时，可以在筏子上执行该操作
and at this point it's okay to execute
that operation a raft you know the

267
00:22:55,089 --> 00:22:59,119
客户端发送请求的键值层Q值层不
client sends a request with the key
value layer Q value layer does not

268
00:22:59,119 --> 00:23:04,579
执行它，所以我们不确定，因为它只有在被复制时才被复制
execute it yet so we're not sure because
it hasn't been replicated only when it's

269
00:23:04,579 --> 00:23:11,779
进出，所有副本的日志随后筏通知领导
in out and the logs of all the replicas
then raft notifies the leader now the

270
00:23:11,779 --> 00:23:15,440
领导者实际执行与您知道的看跌期权相对应的操作
leader actually execute the operation
which corresponds to you know for a put

271
00:23:15,440 --> 00:23:22,039
更新值，但仍从表中读取正确的值，然后最终
updating the value yet reading correct
value out of the table and then finally

272
00:23:22,039 --> 00:23:34,759
将回复发送回客户端，这是它的常规操作
sends the reply back to the client so
that's the ordinary operation of it

273
00:23:34,759 --> 00:23:38,479
提交，如果它是大多数，那么我不能全部成为的原因是
submitted if it's in a majority and
again the reason why I can't be all is

274
00:23:38,479 --> 00:23:41,299
如果我们要构建一个容错系统，它必须能够
that if we want to build a
fault-tolerant system it has to be able

275
00:23:41,299 --> 00:23:49,449
即使某些服务器出现故障也能取得进步，所以
to make progress even if some of the
server's have failed so yeah so ever

276
00:23:49,449 --> 00:23:53,679
当它占多数时就承诺
it's committed when it's in a majority

277
00:23:54,720 --> 00:23:57,890
 [音乐] 
[Music]

278
00:24:08,170 --> 00:24:14,770
是的，另外，当操作最终提交每个副本时， 
yeah and so in addition when operations
finally committed each of the replicas

279
00:24:14,770 --> 00:24:20,780
将操作发送到每个筏库层
sends the operation up each of the raft
library layer sends the operation up to

280
00:24:20,780 --> 00:24:24,590
本地应用程序层中的本地应用程序层将应用该操作
the local application layer in the local
application layer applies that operation

281
00:24:24,590 --> 00:24:29,300
到它的状态到它的状态，所以他们都希望所有复制品看起来像
to its state its state and so they all
so hopefully all the replicas seem the

282
00:24:29,300 --> 00:24:34,760
它们以相同的顺序出现在这些up呼叫中的相同操作流
same stream of operations they show up
in these up calls in the same order they

283
00:24:34,760 --> 00:24:38,960
以相同的顺序应用于状态，并且您知道
get applied to the state in the same
order and you know assuming the

284
00:24:38,960 --> 00:24:45,920
操作是确定性的，最好是副本的状态
operations are deterministic which they
better be the state of the replicas

285
00:24:45,920 --> 00:24:50,360
复制状态将在所有副本上以相同的方式演化，因此
replicated State will evolve in
identically on all the replicas so

286
00:24:50,360 --> 00:24:55,780
通常，此表是论文在讨论时要讨论的内容
typically this this table is what the
paper is talking about when it talks

287
00:24:55,780 --> 00:25:05,480
关于陈述这种互动方式的另一种方式， 
about state a different way of viewing
this interaction and one that'll sort of

288
00:25:05,480 --> 00:25:10,220
在此过程中会出现很多符号是一种时间图
notation that will come up a lot in this
course is that a sort of time diagram

289
00:25:10,220 --> 00:25:13,850
我将为您绘制消息工作原理的时间图，让我们假设我们有一个
I'll draw you a time diagram of how the
messages work so let's imagine we have a

290
00:25:13,850 --> 00:25:23,750
客户和服务器一是领导者，我们也有服务器到服务器三， 
client and server one is the leader that
we also have server to server three and

291
00:25:23,750 --> 00:25:27,470
时间在此图上向下流动，我们想象客户端发送原始
time flows downward on this diagram we
imagine the client sending the original

292
00:25:27,470 --> 00:25:35,330
在该服务器的筏层发送附加条目后，向服务器一请求
request to server one after that server
ones raft layer sends an append entries

293
00:25:35,330 --> 00:25:44,530
 RPC到两个副本的每一个，这只是普通的，我会说一个put请求
RPC to each of the two replicas this is
just an ordinary I'll say a put request

294
00:25:44,530 --> 00:25:51,980
这是附加条目，请求服务器现在正在等待答复，并且
this is append entries requests the
server is now waiting for replies and

295
00:25:51,980 --> 00:25:58,280
来自大多数副本的服务器会尽快从其他副本返回服务器
the server's from other replicas as soon
as replies from a majority arrive back

296
00:25:58,280 --> 00:26:02,090
包括领导者本身，所以在一个只有三个左右的系统中，因为
including the leader itself so in a
system with only three about because the

297
00:26:02,090 --> 00:26:06,679
领导者只需要等待另一个副本对一个
leader only has to wait for one other
replica to respond positively to an

298
00:26:06,679 --> 00:26:14,380
一旦收集到多数人的正面回应，就追加条目
append entries as soon as it assembles
positive responses from a majority the

299
00:26:14,380 --> 00:26:18,230
领导者执行命令找出什么
leader
execute a command figures out what the

300
00:26:18,230 --> 00:26:25,420
答案就像忘记，然后将回复发送回客户端
answer is like forget
and sends the reply back to the client

301
00:26:25,420 --> 00:26:30,700
我的意思是，为什么您当然知道如果某人实际上还活着，会发回
I mean why of course you know if s who's
actually awry alive it'll send back its

302
00:26:30,700 --> 00:26:35,470
也有回应，但我们不必等待，尽管了解和
response too but we're not waiting for
it although it's useful to know and

303
00:26:35,470 --> 00:26:43,120
图-好的每个人都看到这是一种普通的操作
figure - all right everybody see this
this is the sort of ordinary operation

304
00:26:43,120 --> 00:26:46,890
系统无故障
of the system no no failures

305
00:26:51,200 --> 00:26:57,560
哦天哪，是的，我喜欢我省略了重要的步骤，所以领导者您知道这一点
oh gosh yeah I like I left out important
steps so you know this point the leader

306
00:26:57,560 --> 00:27:01,520
知道哦，我知道你知道我是adora没写在日志里，我可以继续
knows oh I got you know I'm adora t have
put it in no log I can go ahead and

307
00:27:01,520 --> 00:27:05,150
执行它并向客户端回复是，因为它已提交但服务器2 
execute it and reply yes to the client
because it's committed but server two

308
00:27:05,150 --> 00:27:07,640
什么都不知道，只是知道你知道我收到了这个请求
doesn't know anything yet it just knows
well you know I got this request from

309
00:27:07,640 --> 00:27:11,780
领导者，但我不知道它是否已经落实取决于
the leader but I don't know if it's
committed yet depends on for example

310
00:27:11,780 --> 00:27:15,260
我的回复是否返回给所有服务器的领导者，知道它的回复是
whether my reply got back to the leader
for all server to knows it's reply was

311
00:27:15,260 --> 00:27:18,710
由网络带来的领导者可能从未听过回复，也从未决定
brought by the network maybe the leader
never heard the reply and never decided

312
00:27:18,710 --> 00:27:24,010
提交此请求，因此一旦服务器出现实际上还有另一个阶段
to commit this request so there's
actually another stage once the server

313
00:27:24,010 --> 00:27:31,070
意识到提交了一个请求，然后需要告诉其他副本
realizes that a request is committed it
then needs to tell the other replicas

314
00:27:31,070 --> 00:27:37,240
这个事实，所以有
that fact and so there are there's

315
00:27:38,320 --> 00:27:42,200
这里有一条额外的消息，确切地说，该消息是多少取决于
there's an extra message here exactly
what that message is depends a little

316
00:27:42,200 --> 00:27:49,520
至少在筏子上发生了什么，这是没有明确的
bit on what what else is going on it's
at least in raft there's not an explicit

317
00:27:49,520 --> 00:27:53,720
提交消息，而不是将信息附加在下一个附录中
commit message instead the information
is piggybacked inside the next append

318
00:27:53,720 --> 00:27:57,620
领导者发送下一个附加项的条目
entries that leader sends out the next
append entries RPC it sends out for

319
00:27:57,620 --> 00:28:01,820
诸如有提交计量表提交之类的原因
whatever reason like there's a commit
meter commit or something filled in that

320
00:28:01,820 --> 00:28:07,880
 RPC和领导者下次需要发送心跳心跳或
RPC and the next time the leader needs
have to send a heartbeat heartbeat or

321
00:28:07,880 --> 00:28:13,370
需要发出新的客户端请求，因为一些不同的客户端请求
needs to send out a new client request
because some different client requests

322
00:28:13,370 --> 00:28:19,280
或它将发出新的雇用领导承诺价值的东西， 
or something it'll send out the new hire
leader commit value and at that point

323
00:28:19,280 --> 00:28:30,790
副本将执行该操作并将其应用于其状态yes 
the replicas will execute the operation
and apply it to their state yes

324
00:28:39,700 --> 00:28:45,270
哦，是的，所以这是一个协议，其中包含很多技巧
oh yes so this is a this is a protocol
that has a quite a bit of chitchat in it

325
00:28:45,270 --> 00:28:53,050
而且它不是超级快，的确，您知道是的，客户端发送了请求请求， 
and it's not super fast indeed you know
yeah client sends in request request has

326
00:28:53,050 --> 00:28:57,460
要进入服务器，服务器与之对话，至少您知道另一个实例
to get to the server the server talks to
at least you know another instance that

327
00:28:57,460 --> 00:29:00,550
多个消息必须等待响应发送回一些东西，所以
multiple messages has to wait for the
responses send something back so there's

328
00:29:00,550 --> 00:29:05,640
一堆消息往返时间在这里嵌入
a bunch of message round-trip times kind
of embedded here

329
00:29:10,760 --> 00:29:17,929
是的，如果是这样，这取决于您作为实施者的实际时间
yes if so this is up to you as the
implementer actually exactly when the

330
00:29:17,929 --> 00:29:26,600
如果客户仅要求复出，领导者将发出更新的提交索引
leader sends out the updated commit
index if client requests a comeback only

331
00:29:26,600 --> 00:29:30,740
有时候，您知道领导者可能想发出心跳
very occasionally then you know the
leader may want to send out a heartbeat

332
00:29:30,740 --> 00:29:37,549
或发送特殊的追加条目消息（如果客户端请求相当多） 
or send out a special append entries
message if client requests come quite

333
00:29:37,549 --> 00:29:40,280
经常那么没关系，因为如果他们来了，你就会知道
frequently then it doesn't matter
because if they come you know there's

334
00:29:40,280 --> 00:29:43,520
每秒到达一千，然后再快一点，很快就会成为另一个
thousand arrive per second and gee so
it'll be another one along very soon and

335
00:29:43,520 --> 00:29:46,669
这样您就可以背负而不产生额外的消息
so you can piggyback so without
generating an extra message which is

336
00:29:46,669 --> 00:29:50,059
有点贵，您可以在下一封邮件中获取信息
somewhat expensive you can get the
information out on the next message you

337
00:29:50,059 --> 00:29:58,820
无论如何都会发送，实际上我不认为复制品的时间
were gonna send anyway in fact I I don't
think the time at which the replicas

338
00:29:58,820 --> 00:30:04,640
执行该请求至关重要，因为至少在没有人等待的情况下， 
execute the request is critical because
nobody's waiting for it at least if

339
00:30:04,640 --> 00:30:10,700
如果没有失败副本执行请求，就不会失败
there's no failures if there's no
failures replicas executing the request

340
00:30:10,700 --> 00:30:13,970
并没有真正走在关键路径上，就像客户不在等待他们一样
isn't really on the critical path like
the client isn't waiting for them the

341
00:30:13,970 --> 00:30:20,540
客户看到我在等待领导者执行，所以可能不是
client saw me waiting for the leader to
execute so it may not be that it may not

342
00:30:20,540 --> 00:30:26,980
影响客户感知到的延迟，确切地讲如何分阶段上演
affect client perceived latency sort of
exactly how this gets staged

343
00:30:37,520 --> 00:30:48,750
好吧，你应该问的一个问题是为什么系统为什么系统如此
all right one question you should ask is
why does the system why is the system so

344
00:30:48,750 --> 00:30:54,930
专注于博客，日志在做什么，这值得一试
focused on blogs what are the logs doing
and it's sort of worth trying to come up

345
00:30:54,930 --> 00:31:00,210
一个明确的答案，一个答案，为什么系统是完全
with an explicit answers to that one
answer to why the system is totally

346
00:31:00,210 --> 00:31:05,700
专注于日志的是日志是领导者通过的一种机制
focused on logs is that the log is the
kind of mechanism by which the leader

347
00:31:05,700 --> 00:31:10,830
命令操作对于这些复制状态机至关重要，因为所有
orders operations it's vital for these
replicated state machines that all the

348
00:31:10,830 --> 00:31:15,720
副本不仅将相同的客户端操作应用于开始，而且将相同
replicas apply not just the same client
operations to their start but the same

349
00:31:15,720 --> 00:31:20,610
操作以相同的顺序进行，但它们都必须应用这些操作
operations in the same order but they
all have to apply that these operations

350
00:31:20,610 --> 00:31:24,240
来自客户端的顺序相同，日志来自其他
coming from the clients in the same
order and the log among many other

351
00:31:24,240 --> 00:31:30,690
事物是领导者或领导者通过其分配命令的机制的一部分
things is part of the machinery by which
the or the leader assigns an order to

352
00:31:30,690 --> 00:31:34,620
我给您的传入客户端操作知道十个客户端将操作发送到
the incoming client operations I give
you know ten clients send operations to

353
00:31:34,620 --> 00:31:37,950
领导者必须同时选择领导者的客户
the leader at the same time the client
the leader has to pick pick an order

354
00:31:37,950 --> 00:31:41,880
确保所有人都遵守该命令，并且日志是您知道的
make sure everybody all the replicas
obey that order and the log is you know

355
00:31:41,880 --> 00:31:46,740
日志在半米的一部分上标有编号的插槽这一事实表示
the fact that the log has numbered slots
as part of half a meter expresses the

356
00:31:46,740 --> 00:31:56,700
顺序选择日志的另一种用途是在这一点和
order it's chosen another use of the log
is that between this point and this

357
00:31:56,700 --> 00:32:02,520
点服务器3收到尚未确定已提交的操作，并且
point server 3 has received an operation
that it is not yet sure is committed and

358
00:32:02,520 --> 00:32:07,440
它无法执行它，但必须将此操作放在某个地方，直到
it cannot execute it yet it has to put
the this operation aside somewhere until

359
00:32:07,440 --> 00:32:13,500
引入领导者提交值的增量，等等， 
the increment to the leader commit value
comes in and so another thing that the

360
00:32:13,500 --> 00:32:17,130
日志所做的是，在关注者上，日志是关注者所在的地方
log is doing is that on the followers
the log is the place where the follower

361
00:32:17,130 --> 00:32:20,490
暂时搁置但已经到来但仍保留的操作
sort of sets aside operations that are
still tentative that have arrived but

362
00:32:20,490 --> 00:32:23,340
还不知道会犯下这些罪行，我们可能会把它们扔掉
are not yet known to be committed and
they may have to be thrown away as we'll

363
00:32:23,340 --> 00:32:29,730
看到，这是另一种用途，我是领导者方面的一种爱
see so that's another use I'm the I sort
of do love that use on the leader side

364
00:32:29,730 --> 00:32:36,300
领导者需要记住其日志中的操作，因为它可能
is that the leader needs to remember
operations in its log because it may

365
00:32:36,300 --> 00:32:40,770
如果某些关注者离线，则需要将其转发给关注者
need to retransmit them to followers if
some followers offline maybe it's

366
00:32:40,770 --> 00:32:42,269
网络短暂发生了一些事情
something briefly happened to its
network

367
00:32:42,269 --> 00:32:46,440
动作或某些内容错过了领导者需要重新发送的某些消息
action or something misses some messages
the leader needs to be able to resend

368
00:32:46,440 --> 00:32:50,700
记录任何追随者错过的消息，因此领导者需要一个地方
log messages that any followers missed
and so the leader needs a place where

369
00:32:50,700 --> 00:32:54,570
可以预留客户端请求消息的副本，甚至是
can set aside copies of messages of
client requests even ones that it's

370
00:32:54,570 --> 00:33:00,539
为了能够将它们重新发送给客户端，我已经执行了
already executed in order to be able to
resend them to the client I mean we send

371
00:33:00,539 --> 00:33:05,879
将它们复制到错过了该操作的副本，这是所有原因的最终原因
them to replicas that missed missed that
operation and a final reason for all of

372
00:33:05,879 --> 00:33:11,009
他们保留日志是至少在图2的世界中，如果有服务器
them to keep the log is that at least in
the world of figure 2 if a server

373
00:33:11,009 --> 00:33:17,759
崩溃并重新启动，并希望重新加入，您真的需要，如果真的
crashes and restarts and wants to rejoin
and you really need if it you really

374
00:33:17,759 --> 00:33:21,599
想要一台崩溃的服务器-实际上，我们启动并重新加入了Raft集群
want a server that crashes - in fact we
start and rejoin the raft cluster

375
00:33:21,599 --> 00:33:24,809
否则，您现在只能使用三台服务器中的两台进行操作， 
otherwise you're now operating with only
two out of three servers and you can't

376
00:33:24,809 --> 00:33:29,399
能够承受更多的失败，我们需要重新整合失败并重新启动
survive any more failures we need to
reincorporate failed and rebooted

377
00:33:29,399 --> 00:33:34,440
服务器，日志是服务器重新启动服务器在何处或使用什么日志
servers and the log is sort of where or
what a server rebooted server uses the

378
00:33:34,440 --> 00:33:39,570
日志保留到其磁盘，因为其中一项规则是每个筏服务器需要
log persisted to its disk because one of
the rules is that each raft server needs

379
00:33:39,570 --> 00:33:42,539
将其日志写入崩溃后仍将保留在其磁盘中的磁盘， 
to write its log to its disk where it
will still be after it crashes and

380
00:33:42,539 --> 00:33:48,239
重新启动该日志是服务器使用或重放该日志中的操作
restarts that log is what the server
uses or replays the operations in that

381
00:33:48,239 --> 00:33:52,709
从头开始记录日志，以创建其崩溃时的状态，然后
log from the beginning to sort of create
its state as of when it crashed and then

382
00:33:52,709 --> 00:33:56,339
然后从那里继续进行，因此日志也用作持久性的一部分
then it carries on from there so the log
is also used as part of the persistence

383
00:33:56,339 --> 00:34:01,129
规划为一系列命令以重建状态
plan as a sequence of commands to
rebuild the state

384
00:34:16,280 --> 00:34:23,339
最终好吧，所以问题在于领导者有能力
well ultimately okay so the question is
suppose the leader is capable of

385
00:34:23,339 --> 00:34:26,879
每秒执行一千个客户端命令，并且仅跟随者
executing a thousand client commands a
second and the followers are only

386
00:34:26,879 --> 00:34:30,179
不能每秒执行一百个客户端命令
incapable of executing a hundred client
commands per second that's sort of

387
00:34:30,179 --> 00:34:41,599
持续速率，您知道全速v，因此需要注意的一件事是
sustained rate you know full speed v so
one thing to note is that the the

388
00:34:41,599 --> 00:34:45,629
复制追随者在执行命令之前确认命令，因此
replicas the followers acknowledge
commands before they execute them so

389
00:34:45,629 --> 00:34:48,750
他们交配的速度是他们承认并在日志中积累的东西
they mate rate at which they acknowledge
and accumulate stuff in their logs is

390
00:34:48,750 --> 00:34:52,469
不受限制，所以您知道他们可以承认每千个请求
not limited so you know maybe they can
acknowledge that a thousand requests per

391
00:34:52,469 --> 00:34:57,690
如果他们永远这样做，那么他们将建立无限大小的日志
second if they do that forever then they
will build up unbounded size logs

392
00:34:57,690 --> 00:35:02,369
因为他们的执行率下降，它将落在后面
because their execution rate falls it
will fall on an unbounded amount behind

393
00:35:02,369 --> 00:35:06,210
领导者根据以下规则提供信息的速率
the rate at which the leader has given
the messages sort of under the rules of

394
00:35:06,210 --> 00:35:11,250
我们的游戏，这意味着它们最终将在以下位置耗尽内存
our game and so what that means they
will eventually run out of memory at

395
00:35:11,250 --> 00:35:15,390
因此，在他们拥有十亿个日志条目之后，他们拥有十亿个条目
some point so after they have a billion
after they fall a billion log entries

396
00:35:15,390 --> 00:35:18,510
就像它们将调用内存分配器为新的空间一样
behind those just like they'll call the
memory allocator for space for a new

397
00:35:18,510 --> 00:35:27,420
博客条目，它将失败，所以是的，Raph没Raph没有流程
blog entry and it will fail so yeah and
Raph doesn't Raph doesn't have the flow

398
00:35:27,420 --> 00:35:34,349
控件来解决这个问题，所以我认为在实际系统中
controls that's required to cope with
this so I think in a real system you

399
00:35:34,349 --> 00:35:37,770
实际上需要您知道您可能piggy带了，并且不需要
would actually need you know probably
piggybacked and doesn't need to be

400
00:35:37,770 --> 00:35:43,920
实时，但您可能需要在此处进行某种形式的附加通信
real-time but you probably need some
kind of additional communication here

401
00:35:43,920 --> 00:35:48,150
那很好，这就是我已经执行了多远，所以领导者
that says well here's how far I've
gotten in execution so that the leader

402
00:35:48,150 --> 00:35:53,099
可以说，您知道在此之前有成千上万的请求
can say well you know too many thousands
of requests ahead of the point in which

403
00:35:53,099 --> 00:35:56,630
追随者已经处决，是的，我想你可能知道
the followers have executed yes I think
there's probably you know in a

404
00:35:56,630 --> 00:36:01,650
您想要将生产系统推向最大极限的生产系统
production system that you're trying to
push to the absolute max you would you

405
00:36:01,650 --> 00:36:05,250
如果距离太远，可能很需要额外的消息来限制领导者
might well need an extra message to
throttle the leader if it got too far

406
00:36:05,250 --> 00:36:07,400
先
ahead

407
00:36:31,700 --> 00:36:38,299
好的，所以问题是这些服务器之一是否崩溃了，是否有此日志
okay so the question is if if one of
these servers crashes it has this log

408
00:36:38,299 --> 00:36:42,890
之所以坚持到磁盘，是因为它是图2的规则之一，所以
that it persisted to disk because that's
one of the rules of figure two so the

409
00:36:42,890 --> 00:36:47,030
服务器将只能从磁盘重新登录，但是该服务器当然
server will be able to be just logged
back from disk but of course that server

410
00:36:47,030 --> 00:36:52,549
不知道执行日志要走多远，也不知道
doesn't know how far it got in executing
the log and also it doesn't know at

411
00:36:52,549 --> 00:36:56,599
至少当它第一次按照图2的规则重新启动时，它甚至不知道如何
least when it first reboots by the rule
that figure two it doesn't even know how

412
00:36:56,599 --> 00:37:00,619
许多日志已提交，因此您问题的第一个答案是
much of the log is committed so the
first answer to your question is that

413
00:37:00,619 --> 00:37:05,599
重新启动后，您立即知道服务器崩溃并重新启动，并且
immediately after a restart you know
after a server crashes and restarts and

414
00:37:05,599 --> 00:37:10,220
读取其日志，因此不允许对其执行任何操作，因为它确实
reads its log it is not allowed to do
anything with the log because it does

415
00:37:10,220 --> 00:37:14,780
不知道系统已经在日志中提交了多长时间
not know how far the system has
committed in its log maybe as long as

416
00:37:14,780 --> 00:37:18,230
它的所有注释都有一千个未提交的条目，零个已提交的条目
has a thousand uncommitted entries and
zero committed entries for all it notes

417
00:37:18,230 --> 00:37:20,799
所以
so

418
00:37:24,810 --> 00:37:28,750
这是一种领先的染料支持，也无济于事，但让我们假设他们已经
it's a leader dye support that doesn't
help either but let's suppose they've

419
00:37:28,750 --> 00:37:33,670
所有人都崩溃了，这已经超越了我，但是很好
all crashed this is getting ahead of its
getting a bit ahead of me but well

420
00:37:33,670 --> 00:37:37,420
假设他们都崩溃了，所以他们所拥有的只是被标记的状态
suppose they've all crashed and so all
they have is the state that was marked

421
00:37:37,420 --> 00:37:42,070
在图2中是非易失性的，其中包括日志和最新的
as non-volatile in figure 2 which
includes the log and maybe the latest

422
00:37:42,070 --> 00:37:46,869
学期，所以他们不知道是否发生了车祸，但他们都崩溃了， 
term and so they don't know some if
there's a crash but they all crash and

423
00:37:46,869 --> 00:37:52,869
他们总是开始，他们都不知道起初他们走了多远
they always start none of them knows
initially how far they had been have

424
00:37:52,869 --> 00:37:57,430
在崩溃之前执行，所以发生的事情是你领导选举
executed before the crash so what
happens is that you leader election one

425
00:37:57,430 --> 00:38:03,820
他们中的一个被选为领导者，而如果您通过某种方式跟踪
of them gets picked as a leader and that
leader if you sort of track through what

426
00:38:03,820 --> 00:38:08,470
图2说明了Rees吊坠应该如何工作，领导者将
figure 2 says about how a pendant Rees
is supposed to work the leader will

427
00:38:08,470 --> 00:38:12,820
实际算是发出吊坠或发出吊坠的副产品
actually figure out as a byproduct of
sending out a pendant or sending out the

428
00:38:12,820 --> 00:38:19,690
第一次心跳真的是假的，它将弄清楚最新的意义是什么
first heartbeat really it'll fake it'll
figure out what the latest point is

429
00:38:19,690 --> 00:38:30,940
基本上，大多数复制品都同意
basically that that all of the that a
majority of the replicas agree on their

430
00:38:30,940 --> 00:38:35,650
法律，因为那是承诺点，另一种看待它的方式是， 
laws because that's the commit point
another way of looking at it is that

431
00:38:35,650 --> 00:38:39,490
通过附加条目机制选择领导者后，领导者
once you choose a leader through the
append entries mechanism the leader

432
00:38:39,490 --> 00:38:44,050
强制所有其他副本对领导者拥有相同的日志，并且
forces all of the other replicas to have
identical logs to the leader and at that

433
00:38:44,050 --> 00:38:48,820
这一点加上论文的一些额外说明，因为
point plus a little bit of extra the
paper explains at that point since the

434
00:38:48,820 --> 00:38:52,570
领导者知道这迫使所有副本拥有它，而我没有日志
leader knows that it's forced all the
replicas to have it I didn't have logs

435
00:38:52,570 --> 00:38:57,119
与它完全相同，那么它知道所有副本还必须具有一个
that are identicals to it then it knows
that all the replicas must also have a

436
00:38:57,119 --> 00:39:03,160
必须有大多数复制品，其中所有这些原木受伤
there must be a majority of replicas
with that all those log injuries in that

437
00:39:03,160 --> 00:39:06,070
现在必须相同的日志也必须提交，因为它们已保存
logs which are now are identical must
also be committed because they're held

438
00:39:06,070 --> 00:39:13,720
在大多数副本上，那时领导者就知道
on a majority of replicas and at that
point a leader you know the append

439
00:39:13,720 --> 00:39:17,800
图2中描述的领导者条目代码将增加领导者
entries code described in Figure 2 for
the leader will increment the leaders

440
00:39:17,800 --> 00:39:21,820
提交点，现在每个人都可以从
commit point and everybody can now
execute the entire log from the

441
00:39:21,820 --> 00:39:29,730
从头开始并重新建立他们的状态，可能非常费力
beginning and recreate their state from
scratch possibly extremely laborious Lee

442
00:39:29,880 --> 00:39:34,930
这就是图二所说的，显然这是从头开始执行的
so that's what figure two says it's
obviously this be executing from scratch

443
00:39:34,930 --> 00:39:40,000
不是很吸引人，但是它是基本协议的所在，我们将看到
is not very attractive but it's where
the basic protocol does and we'll see

444
00:39:40,000 --> 00:39:44,110
明天，这种版本的版本将更有效地用作
tomorrow that the the sort of version of
this is more efficient to use as

445
00:39:44,110 --> 00:39:50,890
检查站，我们明天再谈，好吧，这是
checkpoints and we'll talk about
tomorrow okay so this was a sequence in

446
00:39:50,890 --> 00:39:54,990
一种普通的非故障操作
sort of ordinary non failure operation

447
00:39:55,380 --> 00:40:00,760
我想简要提及的另一件事是该界面看起来像您
another thing I want to briefly mention
is what this interface looks like you've

448
00:40:00,760 --> 00:40:05,410
由于在实验室工作，可能所有人都看到了一点，但大致
probably all seen a little bit of it due
to working on the labs but roughly

449
00:40:05,410 --> 00:40:12,400
如果您要说说这个键值层及其状态和
speaking if you have let's say that this
key value layer with its state and the

450
00:40:12,400 --> 00:40:18,330
底下的木筏层每个副本上确实有两个主要部分
raft layer underneath it there's on each
replica there's really two main pieces

451
00:40:18,330 --> 00:40:24,010
它们之间的接口的键值层使用这种方法
of the interface between them there's
this method by which the key value layer

452
00:40:24,010 --> 00:40:27,910
如果客户端发送请求，则可以中继键值层必须将其交给
can relay if a client sends in a request
the key value layer has to give it to

453
00:40:27,910 --> 00:40:31,420
包装并说请您知道将此请求放入日志中的某个位置，然后
wrap and say please you know fit this
request into the log somewhere and

454
00:40:31,420 --> 00:40:40,420
那是您在Raph go中看到的开始功能，实际上只需要一个
that's the start function that you'll
see in Raph go and really just takes one

455
00:40:40,420 --> 00:40:45,550
争论客户命令他们说的关键值，请给我
argument the client command the key
value they're saying please I got this

456
00:40:45,550 --> 00:40:50,320
命令进入日志，并告诉我何时提交日志以及其他内容
command to get into the log and tell me
when it's committed and the other piece

457
00:40:50,320 --> 00:40:55,930
界面的是筏层通过by会通知键值
of the interface is that by and by the
raft layer will notify the key value

458
00:40:55,930 --> 00:40:59,740
您在启动命令中向我发送的AHA操作层
layer that AHA that operation that you
sent to me in a start command a while

459
00:40:59,740 --> 00:41:03,430
以前，这可能不是最近的开始，您知道
ago which may well not be the most
recent start right there you know a

460
00:41:03,430 --> 00:41:07,600
一百个客户端命令可能会进入，并导致在任何以下命令之前开始调用
hundred client commands could come in
and cause calls to start before any of

461
00:41:07,600 --> 00:41:14,260
他们做出了这样的承诺，并通过这种向上的沟通采取了形式
them are committed so by and by this
upward communication is takes the form

462
00:41:14,260 --> 00:41:20,170
筏库发送的go通道上的消息的种类和键值
of a message on a go channel that the
raft library sends on and key value

463
00:41:20,170 --> 00:41:28,120
层应该从中读取，所以有一个称为Apply的apply 
layer is supposed to read from so
there's this apply called the apply

464
00:41:28,120 --> 00:41:33,900
频道并在其上发送申请消息
channel and on it on it you send apply
message

465
00:41:37,440 --> 00:41:42,310
这个开始，当然您需要键值层能够
this start and of course you need the
the key value layer needs to be able to

466
00:41:42,310 --> 00:41:47,430
匹配消息，该消息接收到带有发起该呼叫的呼叫的应用频道
match up message that receives an apply
channel with calls to start that it made

467
00:41:47,430 --> 00:41:52,599
因此start命令实际上返回了足够的信息
and so the start command actually
returns enough information for that

468
00:41:52,599 --> 00:41:58,540
发生匹配，它返回启动函数基本上返回的索引
matchup to happen it returns the index
that start functions basically returns

469
00:41:58,540 --> 00:42:02,170
日志中的索引（如果此命令已提交，则该索引可能未提交） 
the index in the log where if this
command is committed which it might not

470
00:42:02,170 --> 00:42:07,150
它将在该索引上提交，我认为它也会返回当前词条
be it'll be committed at this index and
I think it also returns the current term

471
00:42:07,150 --> 00:42:11,589
还有一些其他我们不太在乎的东西，那么这个应用信息就是
and some other stuff we don't care about
very much and then this apply message is

472
00:42:11,589 --> 00:42:27,970
将包含index命令，并且所有副本都将应用这些副本
going to contain the index command and
all the replicas will get these apply

473
00:42:27,970 --> 00:42:33,520
消息，所以他们都会知道，尽管我应该将此命令弄清楚
messages so they'll all know though I
should apply this command figure out

474
00:42:33,520 --> 00:42:37,510
该命令的含义并将其应用到我的当地州，他们也得到了
what this command means and apply it to
my local State and they also get the

475
00:42:37,510 --> 00:42:42,280
索引索引实际上仅对我有用，我是领导者，因此它可以弄清楚
index the index is really only useful
I'm the leader so it can figure out what

476
00:42:42,280 --> 00:42:46,109
客户会谈论客户的要求
client would what client requests were
talking about

477
00:43:00,890 --> 00:43:03,890
通过
by

478
00:43:14,410 --> 00:43:18,910
答案是一个稍有不同的问题，让我们假设客户端发送了
the answer a slightly different question
let's suppose the client sends any

479
00:43:18,910 --> 00:43:23,410
让我们说这是一个看跌期权或一个看跌期权，或者实际上不是
request in let's say it's a put or a get
could be put or again it doesn't really

480
00:43:23,410 --> 00:43:32,500
我要说的是要让客户明白这一点
matter I'd say it to get the point in
which the it's a client sense and again

481
00:43:32,500 --> 00:43:37,000
并等待响应，领导者将在以下时间发送响应
and waits for a response the point at
which the leader will send a response at

482
00:43:37,000 --> 00:43:41,680
一切都是在领导者知道命令已提交之后，所以这将
all is after the leader knows that
command is committed so this is going to

483
00:43:41,680 --> 00:43:52,230
是一种获得回复的方法，这样客户就看不到我的意思了，所以
be a sort of get reply so the client
doesn't see anything back I mean and so

484
00:43:52,230 --> 00:43:56,830
就实际软件堆栈而言，这意味着密钥
that means in terms of the actual
software stack that means that the key

485
00:43:56,830 --> 00:44:02,020
值RPC将到达键值层将调用start函数
value the RPC will arrive the key value
layer will call the start function the

486
00:44:02,020 --> 00:44:06,700
启动功能将返回到键值层，但键值层将
start function will return to the key
value layer but the key value layer will

487
00:44:06,700 --> 00:44:10,840
尚未回复客户，因为它实际上不知道是否很好
not yet reply to the client because it
does not know if it's good actually it

488
00:44:10,840 --> 00:44:13,840
现在还没有执行客户的请求，甚至都不知道是否会
hasn't executed the clients request now
it doesn't even know if it ever will

489
00:44:13,840 --> 00:44:18,820
因为不确定该请求是否会在
because it's not sure if the request is
going to be committed right in the

490
00:44:18,820 --> 00:44:23,590
可能不会提交的情况是您知道的键值层是否在猜测
situation which may not be committed is
if the key value layer you know guess

491
00:44:23,590 --> 00:44:27,160
请求调用开始，右舷右转两次后立即崩溃
the request calls start and immediately
after starboard turn two crashes right

492
00:44:27,160 --> 00:44:30,220
当然还没有发出应用附加消息或其他内容的信息
certainly hasn't sent out its apply what
append messages or whatever

493
00:44:30,220 --> 00:44:36,600
是的，什么也不做，所以游戏是开始返回时间过去了
nothing's be committed yep so so the
game is start returns time passes the

494
00:44:36,600 --> 00:44:42,490
与该客户请求相对应的相关应用消息出现在密钥上
relevant apply message corresponding to
that client request appears to the key

495
00:44:42,490 --> 00:44:47,440
值服务器仅在应用通道上，然后才导致键值
value server on the apply channel and
only then and that causes the key value

496
00:44:47,440 --> 00:44:53,010
服务器执行请求并将其发送给她
server to execute the request and send
her a plot

497
00:44:58,230 --> 00:45:02,170
这就像当一切都不重要时，这一切非常重要
and that's like all this is very
important when it doesn't really matter

498
00:45:02,170 --> 00:45:06,640
如果一切顺利，但如果失败了，我们现在就到了
if all everything goes well but if
there's a failure we're now at the point

499
00:45:06,640 --> 00:45:09,760
我们开始担心剧院的地方我的意思是对那里非常感兴趣
where we start worrying about theatres I
mean extremely interested in if there

500
00:45:09,760 --> 00:45:13,140
失败了，客户看到了什么
was a failure what did the client see

501
00:45:13,950 --> 00:45:23,710
好的，所以一件事就是你们所有人都应该
all right and so one thing that does
come up is that all of you should be

502
00:45:23,710 --> 00:45:26,710
至少对此一开始就很熟悉
familiar with this that at least
initially one interesting thing about

503
00:45:26,710 --> 00:45:30,760
日志是它们可能不相同，有一堆
the logs is that they may not be
identical there are a whole bunch of

504
00:45:30,760 --> 00:45:36,369
至少在短时间内结束的情况
situations in which at least for brief
periods of time the ends of the

505
00:45:36,369 --> 00:45:41,710
不同的副本日志可能会有所不同，例如，如果领导者开始发送
different replicas logs may diverge like
for example if a leader starts to send

506
00:45:41,710 --> 00:45:45,160
发出一轮附加消息，但是在发送所有消息之前崩溃
out a round of append messages but
crashes before it's able to send all

507
00:45:45,160 --> 00:45:48,100
他们出来，你知道那意味着获得附件的一些副本
them out you know that'll mean that some
of the replicas that got the append

508
00:45:48,100 --> 00:45:51,940
消息将追加，您知道新的日志条目和未获得的日志条目
message will append you know that new
log entry and the ones that didn't get

509
00:45:51,940 --> 00:45:56,440
附加消息RPC不会附加它们，因此很容易看到
that append messages RPC won't have
appended them so it's easy to see that

510
00:45:56,440 --> 00:46:02,859
日志是我有时会发散的好消息是木筏的方式
the logs are I'm gonna diverge sometimes
the good news is that the the way a raft

511
00:46:02,859 --> 00:46:08,230
工作实际上最终迫使日志在一段时间后变得相同
works actually ends up forcing the logs
to be identical after a while there may

512
00:46:08,230 --> 00:46:13,240
是暂时的差异，但从长远来看，所有日志都将是
be transient differences but in the long
run all the logs will sort of be

513
00:46:13,240 --> 00:46:17,140
由领导者修改，直到领导者保险公司都完全相同，然后
modified by the leader until the leader
insurers are all identical and only then

514
00:46:17,140 --> 00:46:27,190
他们执行得还好吗，所以我认为接下来确实有两个大话题
are they executed okay so I think the
next there's really two big topics to

515
00:46:27,190 --> 00:46:31,450
在这里谈论筏一是领导者选举的工作原理，这是实验二
talk about here for raft one is how
leader election works which is lab two

516
00:46:31,450 --> 00:46:37,270
另一个是领导者如何处理不同的副本日志
and the other is how the leader deals
with the different replicas logs

517
00:46:37,270 --> 00:46:42,690
特别是失败之后，所以首先我想谈谈领导人选举
particularly after failure so first I
want to talk about leader election

518
00:46:44,940 --> 00:46:48,880
要问的问题是系统为什么甚至有领导者，为什么我们需要一个
question to ask is how come the system
even has a leader why do we need a

519
00:46:48,880 --> 00:46:53,710
领导者答案的一部分是您不需要领导者来构建像
leader the part of the answer is you do
not need a leader to build a system like

520
00:46:53,710 --> 00:46:59,140
这样您就可以建立一个协议系统，通过该协议系统
this you it is possible to build an
agreement system by which a cluster of

521
00:46:59,140 --> 00:47:04,210
服务器同意您知道日志中的条目顺序，而没有任何种类
servers agrees you know the sequence of
entries in a log without having any kind

522
00:47:04,210 --> 00:47:07,960
指定领导者的确是原始包装系统
of designated leader
and indeed the original pack so system

523
00:47:07,960 --> 00:47:13,150
该文件指出原始Paxos没有领导者，因此有可能
which the paper refers to original Paxos
did not have a leader so it's possible

524
00:47:13,150 --> 00:47:18,790
木筏之所以有领导者，基本上是因为
the reason why raft has a leader is
basically that there's probably a lot of

525
00:47:18,790 --> 00:47:22,150
原因，但最重要的原因之一是您可以构建更高效的
reasons but one of the foremost reasons
is that you can build a more efficient

526
00:47:22,150 --> 00:47:27,130
在服务器不出现故障的常见情况下，可以构建更多的服务器
in the common case in which the server's
don't fail it's possible to build a more

527
00:47:27,130 --> 00:47:30,640
有效的系统，如果您有领导者，因为有指定的领导者
efficient system if you have a leader
because with a designated leader

528
00:47:30,640 --> 00:47:37,540
每个人都知道领导者是谁，您基本上可以就要求达成协议
everybody knows who the leader is you
can basically get agreement on requests

529
00:47:37,540 --> 00:47:41,470
作为每个系统的负责人，每个请求只有一轮消息
that with one round of messages per
request where as leader of this systems

530
00:47:41,470 --> 00:47:45,580
拥有更多的风味，您需要进行第一轮谈判才能达成共识
have more of the flavor of well you need
a first round to kind of agree on a

531
00:47:45,580 --> 00:47:50,619
临时负责人，然后进行第二轮实际发出请求，因此
temporary leader and then a second round
actually send out the requests so it's

532
00:47:50,619 --> 00:47:56,610
现在使用领导者的情况可能使系统速度提高了两倍
probably the case that use of a leader
now speeds up the system by a factor two

533
00:47:56,610 --> 00:48:04,210
而且也使人们更容易思考筏上发生的事情
and it also makes it sort of easier to
think about what's going on raft goes

534
00:48:04,210 --> 00:48:11,170
通过一系列领导者，它使用这些术语编号来进行排序
through a sequence of leaders and it
uses these term numbers in order to sort

535
00:48:11,170 --> 00:48:14,350
歧义的我们正在谈论的那个领导者原来
of disambiguate which leader we're
talking about it turns out that

536
00:48:14,350 --> 00:48:17,380
追随者真的不需要知道他们真正的领导者的身份
followers don't really need to know the
identity of the leader they really just

537
00:48:17,380 --> 00:48:23,200
需要知道当前术语号是每个术语最多有一个
need to know what the current term
number is each term has at most one

538
00:48:23,200 --> 00:48:27,369
领导者，这是您每个学期都知道的重要财产
leader that's a critical property you
know for every term there might be no

539
00:48:27,369 --> 00:48:31,359
在那个任期内的领导者，或者可能有一个领导者，但不能有两个
leader during that term or there might
be one leader but there cannot be two

540
00:48:31,359 --> 00:48:42,190
在同一任期的领导者中，每个任期都必须有最多一位领导者
leaders during the same term every term
has it must most one leader how do the

541
00:48:42,190 --> 00:48:48,100
领导者首先被创造出来，每个木筏服务器都保持着这次选举
leaders get created in the first place
every raft server keeps this election

542
00:48:48,100 --> 00:48:52,030
计时器，这只是一个时间，它基本上只是记录下来的时间而已
timer which is just a it's basically
just out of time that it has recorded

543
00:48:52,030 --> 00:48:56,320
那很好，如果那个时间发生，我将要做某事
that says well if that time occurs I'm
going to do something and the something

544
00:48:56,320 --> 00:49:02,470
的确是，如果整个领导人选举期满而没有
that it does is that if an entire leader
election period expires without the

545
00:49:02,470 --> 00:49:08,140
服务器听到当前领导者的任何消息，然后服务器
server having heard any message from the
current leader then the server sort of

546
00:49:08,140 --> 00:49:12,580
假设当前领导者已经去世并开始选举，那么我们
assumes probably that the current leader
is dead and starts an election so we

547
00:49:12,580 --> 00:49:15,480
有这个选举计时器
have this election timer

548
00:49:17,869 --> 00:49:23,630
如果到期，我们开始选举
and if it expires we start an election

549
00:49:28,460 --> 00:49:35,570
而开始选举的意思基本上是您增加任期
and what it means to start an election
is basically that you increment the term

550
00:49:35,570 --> 00:49:39,930
将服务器确定为候选服务器的候选服务器， 
the the candidate the server that's
decided it's going to be a candidate and

551
00:49:39,930 --> 00:49:43,950
一种新的选举首先增加了这个任期，因为它想要
sort of force a new election first
increments this term because it wants

552
00:49:43,950 --> 00:49:47,880
他们要成为新的领导者，本身就是领导者，你知道领导者一个词不能
them to be a new leader namely itself
and you know leader a term can't have

553
00:49:47,880 --> 00:49:51,770
不止一位领导者，所以我们必须开始新的任期才能拥有新的领导者
more than one leader so we got to start
a new term in order to have a new leader

554
00:49:51,770 --> 00:50:00,840
然后发出这些请求，船是我要发送的豌豆种子
and then it sends out these requests
boats are pea seeds I'm going to send

555
00:50:00,840 --> 00:50:05,130
发出一轮完整的请求票，您可能只需要发送n减
out a full round of request votes and
you may only have to send out n minus

556
00:50:05,130 --> 00:50:08,340
一个人要求投票，因为其中一项规则是，新候选人总是
one requests votes because one of the
rules is that a new candidate always

557
00:50:08,340 --> 00:50:16,470
在选举中为自己投票，因此要注意的一件事是
votes for itself in the election so one
thing to note about this is that it's

558
00:50:16,470 --> 00:50:19,380
如果领导者没有失败，我们就不会进行选举
not quite the case that if the leader
didn't fail we won't have an election

559
00:50:19,380 --> 00:50:24,480
但是如果领导者确实失败了，那么我们将以任何
but if the leader does fail then we will
have election an election assuming any

560
00:50:24,480 --> 00:50:28,230
其他服务器启动，因为有一天其他服务器选举计时器走了
other server is up because some day the
other servers election timers go will go

561
00:50:28,230 --> 00:50:32,400
离开，但由于领导者没有失败，我们可能仍会不幸举行选举，因此
off but as leader didn't fail we might
still unfortunately get an election so

562
00:50:32,400 --> 00:50:37,050
如果网络速度慢或出现一些心跳或某些问题，我们可能最终会失败
if the network is slow or drops a few
heartbeats or something we may end up

563
00:50:37,050 --> 00:50:40,440
即使有一个非常好的领导者，选举计时器也会关闭
having election timers go off and even
though there was a perfectly good leader

564
00:50:40,440 --> 00:50:43,740
尽管如此，我们可能还是要进行新的选举，所以我们必须牢记这一点
we may nevertheless have a new election
so we have to sort of keep that in mind

565
00:50:43,740 --> 00:50:48,510
当我们在考虑正确性及其含义时
when we're thinking about the
correctness and what that in turn means

566
00:50:48,510 --> 00:50:52,410
就是如果有新的选举，很可能旧的情况
is that if there's a new election it
could easily be the case that the old

567
00:50:52,410 --> 00:50:56,190
领导者仍然闲逛，仍然认为这是领导者，好像
leader is still hanging around and still
thinks it's the leader like if there's a

568
00:50:56,190 --> 00:51:00,869
例如，网络分区，旧的领导者仍然活着，并且在
network partition for example and the
old leader is still alive and well in a

569
00:51:00,869 --> 00:51:05,280
少数党派多数党派可能进行选举，实际上
minority partition the majority
partition may run an election and indeed

570
00:51:05,280 --> 00:51:09,990
一次成功的选举并选择一位新领导人，而这一切都是未知的
a successful election and choose a new
leader all totally unknown to the

571
00:51:09,990 --> 00:51:13,530
以前的领导者，所以我们也必须担心您知道那是什么
previous leader so we also have to worry
about you know what's that previous

572
00:51:13,530 --> 00:51:19,400
领导人会这样做，因为它不知道会有新的选举
leader gonna do since it does not know
there was a new election yes

573
00:51:42,130 --> 00:51:46,940
好的，所以问题是，是否会有病理情况
okay so the question is are there can
there be pathological cases in which for

574
00:51:46,940 --> 00:51:52,339
单向网络通信示例可能会阻止系统
example one-way network communication
can prevent the system from making

575
00:51:52,339 --> 00:51:56,930
进展，我相信答案肯定是肯定的，例如，如果当前
progress I believe the answer is yes
certainly so for example if the current

576
00:51:56,930 --> 00:52:02,839
如果其网络由于某种原因导致一半失败，则当前领导者可以发送出去
leader if its network somehow half fails
in a way the current leader can send out

577
00:52:02,839 --> 00:52:07,280
心跳，但无法接收任何客户端请求
heartbeats
but can't receive any client requests

578
00:52:07,280 --> 00:52:11,869
那么它发出的心跳就会传递出来，因为
then the heartbeats that it sends out
which are delivered because it's

579
00:52:11,869 --> 00:52:18,109
传出网络连接正常工作，其传出心跳将抑制任何
outgoing network connection works its
outgoing heartbeats will suppress any

580
00:52:18,109 --> 00:52:22,280
从其他服务器开始选举，但事实是它是传入网络
other server from starting an election
but the fact that it's incoming Network

581
00:52:22,280 --> 00:52:26,720
为什么或显然被破坏将阻止它听到并执行任何客户
why or apparently is broken will prevent
it from hearing and executing any client

582
00:52:26,720 --> 00:52:35,359
命令，这绝对是筏不能抵抗各种威胁的情况
commands it's absolutely the case that
raft is not proof against all sort of

583
00:52:35,359 --> 00:52:38,900
可能出现的所有疯狂的网络问题我相信我已经想到的问题
all crazy Network problems that can come
up I believe the ones I've thought about

584
00:52:38,900 --> 00:52:46,970
我认为可以解决这个问题，因为我们可以通过
I believe are fixable in the sense that
the we could solve this one by having a

585
00:52:46,970 --> 00:52:51,770
需要一种双向心跳，如果领导者发出心跳
sort of requiring a two-way heartbeat in
which if the leader sends out heartbeats

586
00:52:51,770 --> 00:52:55,700
但是您知道有些人需要在其中回复
but you know there were in which
followers are required to reply in some

587
00:52:55,700 --> 00:52:59,240
心跳的方式我想如果领导者已经要求应用它们
way to heartbeats I guess they are
already required to apply if the leader

588
00:52:59,240 --> 00:53:04,460
一段时间之后，停止查看对其心跳的回复，并且
stop seeing replies to its heartbeats
then after some amount of time and which

589
00:53:04,460 --> 00:53:09,230
是季节决定，领导者决定辞职我觉得那很具体
is seasonals replies the leader decides
to step down I feel like that specific

590
00:53:09,230 --> 00:53:16,069
这个问题可以解决，许多其他问题也可以解决，但是我但是你知道你是绝对的
issue can be fixed and many others can
too but I but you know you're absolutely

591
00:53:16,069 --> 00:53:19,599
对，网络中可能会发生非常奇怪的事情，包括一些
right that very strange things can
happen to networks including some that

592
00:53:19,599 --> 00:53:23,589
该协议没有准备好
the protocol is not prepared for

593
00:53:28,740 --> 00:53:33,849
好，所以我们进行了这些电表选择，我们需要确保最多
okay so we got these meter elections we
need to ensure that there is at most at

594
00:53:33,849 --> 00:53:38,080
每学期最多一米Rath如何做到这一点Rath要求
most one meter per term
how does Rath do that well Rath requires

595
00:53:38,080 --> 00:53:42,700
为了当选一职，筏需要候选人获得赞成票
in order to be elected for a term Raft
requires a candidate to get yes votes

596
00:53:42,700 --> 00:53:47,980
从大多数服务器的服务器中提取，并且每个服务器只会
from a majority of the server's the
servers and each server will only cast

597
00:53:47,980 --> 00:53:55,690
每学期一次赞成票，因此在任何给定学期中，您基本上都知道
one yes vote per term so in any given
term you know it basically means that in

598
00:53:55,690 --> 00:54:01,060
任何给定学期的复活节只对你没有的一个候选人投票一次
any given term Easter votes only once
for only one candidate you can't have

599
00:54:01,060 --> 00:54:06,570
两个候选人都获得多数票，因为每个人只能投票一次
two candidates both get a majority of
votes because everybody votes only once

600
00:54:06,570 --> 00:54:11,530
所以多数人多数统治导致最多有一场胜利
so the majorities majority rule causes
there to be at most one winning

601
00:54:11,530 --> 00:54:21,150
候选人，那么我们每回合最多选举一名候选人
candidate and so then we get at most one
candidate elected per turn

602
00:54:24,450 --> 00:54:31,930
另外，至关重要的是，多数原则意味着您甚至可以当选
and in addition critically the majority
rule means that you can get elected even

603
00:54:31,930 --> 00:54:36,010
如果某些服务器崩溃了如果不是少数服务器崩溃了
if some servers have crashed right if a
minority of servers are crashed aren't

604
00:54:36,010 --> 00:54:39,700
可用和网络问题，如果超过一半
available and network problems we can
still elect a leader if more than half a

605
00:54:39,700 --> 00:54:43,390
崩溃或不可用或在另一个分区中或实际上然后
crash or not available or in another
partition or something then actually the

606
00:54:43,390 --> 00:54:47,080
系统只会坐在那里一次又一次地选举一位领导者，从不
system will just sit there trying again
and again to elect a leader and never

607
00:54:47,080 --> 00:54:54,730
如果实际上不能选出一台不占多数的实时服务器，则选择一个
elect one if it cannot in fact they're
not a majority of live servers if an

608
00:54:54,730 --> 00:54:58,960
选举成功，如果每个人都了解我，那么每个人都会很棒
election succeeds everybody would be
great if everybody learned about it I

609
00:54:58,960 --> 00:55:02,980
意思是需要问自己所有各方如何学习了解发生了什么
mean need to ask ourselves how do all
the parties learn learn what happened

610
00:55:02,980 --> 00:55:07,300
赢得选举的服务器（假设它不会使服务器崩溃） 
the server that wins an election
assuming it doesn't crash the server

611
00:55:07,300 --> 00:55:12,730
赢得选举的人实际上将获得多数或赞成票
that wins election will actually see a
majority or positive votes for its

612
00:55:12,730 --> 00:55:17,740
请求其他大多数服务器的投票，以便候选人运行
request vote from a majority of the
other servers so the candidates running

613
00:55:17,740 --> 00:55:20,710
赢得选举的选举赢得选举的肯尼迪实际上将
the election that wins it the Kennedy
that wins the election will actually

614
00:55:20,710 --> 00:55:26,020
直接知道呃我获得了大多数选票，但是没有其他人直接知道谁
know directly uh I got a majority of
votes but nobody else directly knows who

615
00:55:26,020 --> 00:55:30,790
获胜者是或是否有人，候选人以这种方式告知其他人
the winner was or whether anybody one so
the way that the candidate informs other

616
00:55:30,790 --> 00:55:34,869
服务器是心跳的规则和数字，如果您在
servers is that heartbeat the rules and
figure to say oh if you're in an

617
00:55:34,869 --> 00:55:37,359
选举您立即要求发送独立
election your immediately required to
send out an independent

618
00:55:37,359 --> 00:55:41,920
现在将所有其他服务器的树添加到心跳附加的附加条目
trees to all the other servers now the
append entries that heartbeat append

619
00:55:41,920 --> 00:55:47,829
条目没有明确表示我赢得了大选，你知道我是任期的领导者
entries doesn't explicitly say I won the
election you know I'm a leader for term

620
00:55:47,829 --> 00:55:53,710
 23它比信息的方式更微妙
23 it's a little more subtle than that
the the way the information is

621
00:55:53,710 --> 00:56:00,249
传达的是除非允许任何人发送附加条目，否则
communicated is that no one is allowed
to send out an append entries unless

622
00:56:00,249 --> 00:56:05,559
他们是那个学期的领导者，所以我是一个事实，你知道我是一个服务器
they're a leader for that term so the
fact that I I'm a you know I'm a server

623
00:56:05,559 --> 00:56:09,579
我看到哦，有一个选举要选举第19届，然后我渐渐发送了
and I saw oh there's an election for
term 19 and then by-and-by I sent an

624
00:56:09,579 --> 00:56:15,009
附加词条为19的条目，告诉我我不知道谁
append entries whose term is 19 that
tells me that somebody I don't know who

625
00:56:15,009 --> 00:56:19,390
但是有人赢得了选举，所以其他服务器才知道他们是
but somebody won the election so that's
how the other servers knows they were

626
00:56:19,390 --> 00:56:24,670
接收该词的附加条目，并且该附加条目还具有
receiving append entries for that term
and that append entries also has the

627
00:56:24,670 --> 00:56:30,279
重置领导者选举时间的效果，只要领导者是
effect of resetting everybody's election
time timer so as long as the leader is

628
00:56:30,279 --> 00:56:34,599
并发出心跳消息或附加条目，至少您知道
up and it sends out heartbeat messages
or append entries at least you know at

629
00:56:34,599 --> 00:56:38,650
服务器每次收到附加条目时应采用的速率
the rate that's supposed to every time a
server receives an append entries it'll

630
00:56:38,650 --> 00:56:45,249
重置其选择计时器，并抑制任何人成为新手
reset its selection timer and sort of
suppress anybody from being a new

631
00:56:45,249 --> 00:56:49,539
只要一切正常，重复的心跳就会
candidate so as long as everything's
functioning the repeated heartbeats will

632
00:56:49,539 --> 00:56:53,859
当然可以防止任何进一步的选举，如果网络出现故障或数据包
prevent any further elections of course
it the network fails or packets are

633
00:56:53,859 --> 00:56:57,880
仍然有可能举行选举，但如果一切顺利，我们会
dropped there may nevertheless be an
election but if all goes well we're sort

634
00:56:57,880 --> 00:57:05,739
不太可能会举行选举，因为该计划可能会失败
of unlikely to get an election this
scheme could fail in the sense that it

635
00:57:05,739 --> 00:57:09,849
不能以公平的方式选举领导人，但可以以失败告终。 
can't fail in the sense of electing to
leaders fair term but it can fail in the

636
00:57:09,849 --> 00:57:14,319
选一个零领导者这个词可能有点早
sense of electing zero leaders for a
term that's sort of morningway it may

637
00:57:14,319 --> 00:57:18,279
失败的原因是，如果有太多服务器出现故障或不可用，或者网络故障
fail is that if too many servers are
dead or unavailable or a bad network

638
00:57:18,279 --> 00:57:21,880
连接，因此，如果您无法聚集多数，则一无所获
connection so if you can't assemble a
majority you can't be elected nothing

639
00:57:21,880 --> 00:57:27,150
发生选举失败的更有趣的方式是
happens the more interesting way in
which an election can fail is if

640
00:57:27,150 --> 00:57:33,130
大家都来了，你知道没有失败没有丢包，只有两个
everybody's up you know there's no
failures no packets are dropped but two

641
00:57:33,130 --> 00:57:38,499
领导人成为候选人的时间足够近，他们可以分开投票
leaders become candidate close together
enough in time that they split the vote

642
00:57:38,499 --> 00:57:43,109
他们之间或说三个领导人
between them or say three leaders

643
00:57:45,020 --> 00:57:49,180
所以假设我们有三升，假设我们有三个复制系统
so supposing we have three liters
supposing we have a three replica system

644
00:57:49,180 --> 00:57:54,760
所有服务器的选举计时器都在同一时间关闭
all their election timers go off at the
same time every server both for itself

645
00:57:54,760 --> 00:57:59,060
然后当他们每个人收到来自另一台服务器的请求投票时
and then when each of them receives a
request vote from another server well

646
00:57:59,060 --> 00:58:02,780
它已经为自己投了票，所以说不，这意味着它
it's already cast its vote for itself
and so it says no so that means that it

647
00:58:02,780 --> 00:58:05,930
服务器的所有三个需求都需要获得一票，每个人都不会获得多数票， 
all three of the server's needs to get
one vote each nobody gets a majority and

648
00:58:05,930 --> 00:58:11,450
没有人当选，因此他们的选举计时器将再次关闭，因为
nobody's elected so then their election
timers will go off again because the

649
00:58:11,450 --> 00:58:14,360
仅当选举计时器获得附加条目但没有领导者时才说
election timers only be said if it gets
an append entries but there's no leader

650
00:58:14,360 --> 00:58:17,930
因此，没有任何附加条目，它们都将再次具有其选举计时器， 
so no append entries they'll all have
their election timers go off again and

651
00:58:17,930 --> 00:58:20,270
如果我们不幸的话，他们都会在同一时间消失
if we're unlucky
they'll all go off at the same time

652
00:58:20,270 --> 00:58:27,140
他们都会全力以赴，没人会获得多数，所以我很清楚
they'll all go for themselves nobody
will get a majority so so clearly I'm

653
00:58:27,140 --> 00:58:31,520
确保大家都知道这一点，还有更多的故事和方式
sure you're all aware at this point
there's more to this story and the way

654
00:58:31,520 --> 00:58:38,720
木筏使得这种分裂投票的可能性变得不可能但并非不可能
Raft makes this possibility of split
votes unlikely but not impossible

655
00:58:38,720 --> 00:58:44,210
是通过随机化这些选举计时器来进行思考的方式以及
is by randomizing these election timers
so the way to think of it and the

656
00:58:44,210 --> 00:58:47,900
随机化的思考方式是假设您有一些时间表
randomization the way to think of it is
that supposing you have some time line

657
00:58:47,900 --> 00:58:54,170
我要在每个人都收到
I'm gonna draw a vents on there's some
point at which everybody received the

658
00:58:54,170 --> 00:58:58,790
最后追加条目正确，然后服务器可能死了，我们假设
last append entries right and then maybe
the server died let's just assume the

659
00:58:58,790 --> 00:59:07,990
服务器发出最后的心跳信号，然后死亡，所有追随者
server send out a last heartbeat and
then died well all of the followers have

660
00:59:08,109 --> 00:59:13,160
这是我们在他们同时收到选举计时器时设置的，因为
this we set their election timers when
they received at the same time because

661
00:59:13,160 --> 00:59:16,040
他们可能都在重置的同时都收到了这个附录
they probably all receive this append
enters at the same time they all reset

662
00:59:16,040 --> 00:59:21,530
他们的选举计时器在将来的某个时候，但他们选择了
their election timers for some point in
the future the future but they chose

663
00:59:21,530 --> 00:59:25,369
将来会有不同的随机时间，然后我们将离开
different random times in the future
which then we're gonna go off

664
00:59:25,369 --> 00:59:30,230
因此，假设死者领导服务器一，现在服务器二和服务器三
so it's suppose the dead leader server
one so now server two and server 3 at

665
00:59:30,230 --> 00:59:34,010
这一点将他们的选举计时器设置为将来的随机点
this point set their election timers for
a random point in the future let's say

666
00:59:34,010 --> 00:59:41,030
服务器将其设置为我喜欢的计时器在这里关闭，服务器3将其设置为
server to set their I like some timer to
go off here and server 3 set its

667
00:59:41,030 --> 00:59:46,210
选举计时器去那里，关于这张图片的关键点是
election timer to go off there and the
crucial point about this picture is that

668
00:59:46,210 --> 00:59:51,260
假设他们选择了不同的随机数，其中一个是第一个
assuming they picked different random
numbers one of them is first and the

669
00:59:51,260 --> 00:59:56,600
另一个是第二个权利，这是这里正在发生的事情，而第一个是第一个
other one is second right that's what's
going on here and the one that's first

670
00:59:56,600 --> 01:00:00,079
假设这个差距足够大
assuming
this gap is big enough the one that's

671
01:00:00,079 --> 01:00:02,869
首先，选举时间将先于其他选举开始
first it's election time will go off
first before the other ones election

672
01:00:02,869 --> 01:00:06,410
计时器，如果我们很近的话，倒霉
timer and if we're close were not
unlucky

673
01:00:06,410 --> 01:00:11,750
它有时间发送一整轮投票请求并从中获取答案
it'll have time to send out a full round
of vote requests and get answers from

674
01:00:11,750 --> 01:00:16,819
在第二次选举计时器之前还活着的所有人
everybody who everybody's alive before
the second election timer goes off from

675
01:00:16,819 --> 01:00:26,140
任何其他服务器，每个人都看到随机化D如何同步
any other server so does everybody see
how the randomization D synchronizes

676
01:00:26,140 --> 01:00:33,230
不幸的是，这些候选人在设置内容方面有些技巧
these candidates unfortunately there's a
bit of art in setting the contents

677
01:00:33,230 --> 01:00:36,490
这些选举计时器的常量存在某种竞争
constants for these election timers
there's some sort of competing

678
01:00:36,490 --> 01:00:43,309
您可能要满足的要求，所以一个显而易见的要求是
requirements you might want to fulfill
so one obvious requirement is that the

679
01:00:43,309 --> 01:00:47,030
选举计时器必须至少与预期的间隔时间相同
election timer has to be at least as
long as the expected interval between

680
01:00:47,030 --> 01:00:49,790
心跳，你知道这很明显
heartbeats
you know this is pretty obvious that the

681
01:00:49,790 --> 01:00:53,690
领导者每隔一百毫秒发出一次心跳
leader sends out heartbeats every
hundred milliseconds you better make

682
01:00:53,690 --> 01:00:57,319
确保没有选举时间或任何人的选举时间是没有意义的
sure there's no point in having the
election time or anybody's election time

683
01:00:57,319 --> 01:01:00,530
或曾经离开Borja 100毫秒，因为那样的话它将消失
or ever go off Borja for 100
milliseconds because then it will go off

684
01:01:00,530 --> 01:01:08,569
在确定下限之前，下限是一个心跳间隔
before the lower limit is certainly the
lower limit is one heartbeat interval in

685
01:01:08,569 --> 01:01:13,700
事实上，因为网络可能会丢弃数据包，所以您可能希望拥有
fact because the network may drop
packets you probably want to have the

686
01:01:13,700 --> 01:01:18,829
最小选举计时器值是心跳间隔的几倍，所以400 
minimum election timer value be a couple
of times the heartbeat interval so 400

687
01:01:18,829 --> 01:01:21,440
您可能想要最短的毫秒心跳
millisecond heartbeats you probably want
to have the very shortest possible

688
01:01:21,440 --> 01:01:26,119
选举时间，或者说300毫秒，您知道的三倍
election time or be you know say 300
milliseconds you know three times the

689
01:01:26,119 --> 01:01:33,710
心跳间隔，这是最小的心跳，所以这
heartbeat interval so that's the sort of
minimum is the heart heartbeat so this

690
01:01:33,710 --> 01:01:39,470
经常你想要最低限度是你知道两次或多次
frequent you want the minimum to be you
know a couple of times that or here so

691
01:01:39,470 --> 01:01:43,010
你知道你将要均匀地随机分配的最大值
what about the maximum you know you're
gonna presumably randomize uniformly

692
01:01:43,010 --> 01:01:50,960
在某些时间范围内，您知道我们应该在哪里设置最大时间
over some range of times you know where
should we set the kind of maximum time

693
01:01:50,960 --> 01:01:57,740
我们在这里随机考虑了一些注意事项
that we're randomizing over there's a
couple of considerations here in a real

694
01:01:57,740 --> 01:02:06,240
您知道这个最大时间影响系统从系统中恢复的速度
system you know this maximum time effect
how quickly the system can recover from

695
01:02:06,240 --> 01:02:11,910
发生故障，因为请记住从服务器发生故障的时间到
failure because remember from the time
at which the server fails until the

696
01:02:11,910 --> 01:02:17,430
第一次选举计时器关闭整个系统被冻结，没有领导者
first election timer goes off the whole
system is frozen there's no leader you

697
01:02:17,430 --> 01:02:20,190
知道客户的要求被抛弃了，因为没有领导者
know the clients requests are being
thrown away because there's no leader

698
01:02:20,190 --> 01:02:24,870
即使您大概知道这些，我们也不会分配新的领导者
and we're not assigning a new leader
even though you know presumably these

699
01:02:24,870 --> 01:02:29,670
其他服务器已启动，因此我们选择此最大啤酒时间长短或延迟
other servers are up so the beer we
choose this maximum the long or delay

700
01:02:29,670 --> 01:02:34,770
我们在恢复发生之前强加给客户端，您知道这是否是
we're imposing on clients before
recovery occurs you know whether that's

701
01:02:34,770 --> 01:02:40,200
重要程度取决于我们需要达到何种高性能以及如何
important depends on sort of how high
performance we need this to be and how

702
01:02:40,200 --> 01:02:44,910
通常我们认为每年都会发生一次失败。 
often we think there will be failures
failures happen once a year then who

703
01:02:44,910 --> 01:02:48,600
关心我们经常期望失败
cares
we're expecting failures frequently we

704
01:02:48,600 --> 01:02:53,670
可能会非常在乎恢复还需要多长时间，所以这是一个考虑因素
may care very much how long it takes to
recover okay so that's one consideration

705
01:02:53,670 --> 01:02:59,400
另一个考虑因素是，这个差距就是预期的时间间隔
the other consideration is that this gap
that is the expected gap in time between

706
01:02:59,400 --> 01:03:04,890
第一次消失了，第二个定时器确实消除了这个差距
the first time are going off and the
second timer going off this gap really

707
01:03:04,890 --> 01:03:09,930
为了有用，必须比候选人花费的时间更长
in order to be useful has to be longer
than the time it takes for the candidate

708
01:03:09,930 --> 01:03:15,060
收集比预期的往返时间更长的所有人的选票
to assemble votes from everybody that is
longer than the expected round-trip time

709
01:03:15,060 --> 01:03:19,050
发送RPC并获得响应所花费的时间，所以也许
the amount of time it takes to send an
RPC and get the response and so maybe it

710
01:03:19,050 --> 01:03:25,860
需要10毫秒来发送RPC并从所有
takes 10 milliseconds to send an RPC and
get a response a response from all the

711
01:03:25,860 --> 01:03:28,980
其他服务器，如果是这种情况，我们需要使最大长度至少更长
other servers and if that's the case we
need to make maximum at least long

712
01:03:28,980 --> 01:03:32,220
足以使两者之间相差10毫秒
enough that there's pretty likely to be
10 milliseconds difference between the

713
01:03:32,220 --> 01:03:37,040
最小随机数和第二个最小随机数
smallest random number and the next
smallest random number

714
01:03:40,550 --> 01:03:54,359
如果您不从测试中恢复，对您来说，测试代码就会感到沮丧
and for you the test code will get upset
if you if you don't recover from a

715
01:03:54,359 --> 01:03:58,920
领导者故障在几秒钟之内，因此，务实地需要调整
leader failure in a couple seconds and
so just pragmatically you need to tune

716
01:03:58,920 --> 01:04:03,720
此最大值降低，因此很有可能您可以完成
this maximum down so that it's highly
likely that you'll be able to complete a

717
01:04:03,720 --> 01:04:09,540
几秒钟之内的领导人选举，但这并不是一个非常严格的限制
leader election within a few seconds but
that's not a very tight constraint any

718
01:04:09,540 --> 01:04:19,910
有关选举超时的问题，一个小问题是您想
questions about the election time outs
one tiny point is that you want to

719
01:04:19,910 --> 01:04:26,700
每当我每次结点时都选择新的随机超时
choose new random time outs every time
there's every time you every time I node

720
01:04:26,700 --> 01:04:31,230
将其设置为像我一样设置其选举计时器，即不要随机选择
sets it to like me sets its election
timer that is don't choose a random

721
01:04:31,230 --> 01:04:36,090
第一次创建服务器时使用的编号，然后我们使用相同的编号
number when the server is first created
and then we use that same number over

722
01:04:36,090 --> 01:04:39,720
一遍又一遍，因为您做出的不幸选择是
and over again because you make an
unlucky choice that is you choose this

723
01:04:39,720 --> 01:04:44,160
一台服务器偶然选择与另一台服务器相同的随机数
one server happens by ill chance to
choose the same random number as another

724
01:04:44,160 --> 01:04:48,830
服务器，这意味着您将永远重复投票
server that means that you're gonna have
split votes over and over again forever

725
01:04:48,830 --> 01:04:53,340
这就是为什么您几乎肯定要选择其他新的随机随机变量的原因
that's why you want to almost certainly
choose a different a new fresh random

726
01:04:53,340 --> 01:05:02,940
每次重置计时器都可以选择选举超时值的编号
number for the election time out value
every time you reset the timer all right

727
01:05:02,940 --> 01:05:09,030
所以关于领导人选举的最后一个问题是假设我们处于这种情况下
so the final issue about leader election
suppose we are in this situation where

728
01:05:09,030 --> 01:05:12,960
旧的领导者分区您知道网络电缆已断开，旧的
the old leaders partition you know the
network cable is broken and the old

729
01:05:12,960 --> 01:05:17,220
领导者那里有几个客户和少数服务器
leader is sort of out there with a
couple clients and a minority of servers

730
01:05:17,220 --> 01:05:21,630
并且网络的另一半占大多数， 
and there's a majority in the other half
of the network and the majority of the

731
01:05:21,630 --> 01:05:28,200
网络的新成员选举一位新领导者，那位老领导者又为什么呢？ 
new half of the network elects a new
leader what about the old leader why why

732
01:05:28,200 --> 01:05:35,390
老领导不会导致执行不正确
won't the old leader cause incorrect
execution

733
01:06:06,310 --> 01:06:12,860
是，针对两个潜在问题，一个是或一个，一些非问题是，如果存在
yes to two potential problems one is or
one some non problem is that if there's

734
01:06:12,860 --> 01:06:17,030
一个领导者离开另一个分区，并且没有下一个分区的多数
a leader off in another partition and it
doesn't have a majority then the next

735
01:06:17,030 --> 01:06:24,260
客户端向它发送请求时，您在分区中认识的那个领导者
time a client sends it a request that
that leader that you know in a partition

736
01:06:24,260 --> 01:06:27,500
是的，它会发送附加条目，但因为它在
with a minority yeah it'll send out
append entries but because it's in the

737
01:06:27,500 --> 01:06:31,940
少数分区，它将无法从大多数
minority partition it won't be able to
get responses back from a majority of

738
01:06:31,940 --> 01:06:36,110
服务器包括它本身，因此它将永远不会提交该操作
the server's including itself and so it
will never commit the operation it will

739
01:06:36,110 --> 01:06:39,830
永远不执行它，永远不会回应客户的说法
never execute it
it'll never respond to the client saying

740
01:06:39,830 --> 01:06:45,860
它执行了它，所以这意味着旧服务器通常
that it executed it either and so that
means that yeah an old server often a

741
01:06:45,860 --> 01:06:49,670
不同的分区，许多客户可能会发送请求，但他们永远都不会得到
different partition people many clients
may send a request but they'll never get

742
01:06:49,670 --> 01:06:56,630
做出回应，因此不会让任何客户误以为该旧服务器
responses so no client will be fooled
into thinking that that old server

743
01:06:56,630 --> 01:07:05,450
为此执行了其他任何更棘手的问题，实际上我会
executed anything for it the other sort
of more tricky issue which actually I'll

744
01:07:05,450 --> 01:07:10,670
在几分钟内谈论的是在服务器故障之前的可能性
talk about in a few minutes is the
possibility that before server fails it

745
01:07:10,670 --> 01:07:17,660
将附加条目发送到一部分服务器，然后在崩溃之前
sends out append entries to a subset of
the servers and then crashes before

746
01:07:17,660 --> 01:07:24,830
提成佣金，作为一个非常有趣的问题，我可能会
making a commission and as a very
interesting question which I'll probably

747
01:07:24,830 --> 01:07:30,050
花了45分钟来讨论，所以实际上在我转向
spend a good 45 minutes talking about
and so actually before I turn to the

748
01:07:30,050 --> 01:07:40,390
返回主题，关于领导者选举的任何其他问题都可以
back topic in general any more questions
about in leader election okay

749
01:07:42,220 --> 01:07:49,160
好吧，那么日志的内容又如何，特别是
okay so how about the contents of the
logs and how in particular how a newly

750
01:07:49,160 --> 01:07:54,440
当选的领导人可能在尴尬的撞车事故后收拾残局
elected leader possibly picking up the
pieces after an awkward crash of the

751
01:07:54,440 --> 01:07:59,630
前任领导人如何重新选举可能产生分歧的新当选领导人
previous leader how does a newly elected
leader sort out the possibly divergent

752
01:07:59,630 --> 01:08:06,140
登录不同的副本，以恢复一致状态
logs on the different replicas in order
to restore sort of consistent state in

753
01:08:06,140 --> 01:08:17,870
系统还可以，所以第一个问题是什么可以认为这是这个
the system all right so the first
question is what can think this is this

754
01:08:17,870 --> 01:08:21,920
整个主题只有在服务器崩溃后才真正有趣，如果
whole topic it's really only interesting
after a server crashes right if the

755
01:08:21,920 --> 01:08:26,930
服务器保持启动状态，那么如果我们有服务器，则相对来说很少会出错
server stays up then relatively few
things can go wrong if we have a server

756
01:08:26,930 --> 01:08:29,870
这是上升的，并且在上升期间您知道的多数
that's up and has a majority you know
during the period of time when it's up

757
01:08:29,870 --> 01:08:35,899
并以多数票数告诉追随者日志的外观
and has a majority it just tells the
followers what the logs should look like

758
01:08:35,899 --> 01:08:39,649
并且不允许追随者不同意他们必须接受他们
and the followers are not allowed to
disagree they're required to accept they

759
01:08:39,649 --> 01:08:43,099
只要按照图二的规则来做，或多或少都会跟上你

760
01:08:43,100 --> 01:08:46,219
知道他们只是接受领导发送给他们的任何独立理由
know they just take whatever the leader
sends them independent reason appended

761
01:08:46,219 --> 01:08:50,299
到日志并服从提交消息并执行，几乎没有什么可做的
to the log and obey commit messages and
execute there's hardly anything to go

762
01:08:50,299 --> 01:08:55,609
当老领导崩溃时，Rapp中出错的地方出错了
wrong the things that go wrong in Rapp
go wrong when a the old leader crashes

763
01:08:55,609 --> 01:09:01,939
在您知道发送消息或新领导导致您崩溃的过程中
sort of midway through you know sending
out messages or a new leader crashes you

764
01:09:01,939 --> 01:09:06,949
在选出之后但做任何事情之前都知道

765
01:09:06,950 --> 01:09:11,779
非常有用，因此我们非常感兴趣的一件事是日志的外观
very useful so one thing we're very
interested in is what can the logs look

766
01:09:11,779 --> 01:09:19,520
像发生了一系列崩溃之后，所以这是一个示例，假设我们有
like after some sequence of crashes okay
so here's an example supposing we have

767
01:09:19,520 --> 01:09:27,589
两台服务器以及我要绘制这些图表的方式，因为我们要
two servers and the way I'm gonna draw
out these diagrams because we're gonna

768
01:09:27,589 --> 01:09:32,988
在很多情况下会看起来像这样的日志
be looking a lot at a lot of sort of
situations where the logs look like this

769
01:09:32,988 --> 01:09:36,649
我们会怀疑这是否可能，如果他们这样做会发生什么
and we're gonna be wondering is that
possible and what happens if they do

770
01:09:36,649 --> 01:09:40,369
看起来像这样，我的记法将是我要写出日志条目

771
01:09:40,370 --> 01:09:47,839
对于每个服务器而言，对齐方式表示插槽对应于
for each of the servers sort of aligned
to indicate slots corresponding slots in

772
01:09:47,839 --> 01:09:53,330
日志和我要在此处写入的值是术语数字，而不是
the log and the values I'm going to
write here are the term numbers rather

773
01:09:53,330 --> 01:09:56,889
比客户操作要多
than
client operations I'm going to you know

774
01:09:56,889 --> 01:10:02,380
这是一个插槽，据认为每个人都看到了第三学期的命令
this is slot one this is thought to
everybody saw a command from term three

775
01:10:02,380 --> 01:10:08,320
在插槽1和服务器调整的服务器3中，也从术语3和
in slot 1 and server tuned server three
saw command from also term three and the

776
01:10:08,320 --> 01:10:14,800
服务器的第二个插槽根本什么都没有，所以对此有疑问
second slot the server one has nothing
there at all and so question for this

777
01:10:14,800 --> 01:10:21,659
像第一个问题是，是否可以到达此设置？ 
like the very first question is can this
arrive could this setup arise and how

778
01:10:21,659 --> 01:10:24,659
是
yes

779
01:11:02,130 --> 01:11:06,280
所以您知道服务器3只是重复您所说内容的领导者
so you know maybe server 3 was the
leader for just repeating what you said

780
01:11:06,280 --> 01:11:09,970
也许服务器3是第3学期的领导者，他收到了发送给
maybe server 3 is the leader for term 3
he got a command that sent out to

781
01:11:09,970 --> 01:11:14,350
每个人都在日志中收到一个家属，然后我得到了一个服务器3 
everybody everybody received a dependent
at the log and then I got a server 3 got

782
01:11:14,350 --> 01:11:19,810
来自客户端的第二个请求，也许它已将其发送到所有三台服务器，但
a second request from a client and maybe
it sent it to all three servers but the

783
01:11:19,810 --> 01:11:23,020
消息在通往服务器一台的途中丢失，或者服务器当时已关闭
message got lost on the way to server
one or maybe server was down at the time

784
01:11:23,020 --> 01:11:28,150
等等，所以只有领导者的服务器总是向其追加新命令
or something and so only server to the
leader always append new commands to its

785
01:11:28,150 --> 01:11:32,380
在发送附加条目之前记录日志，也许附加条目RPC仅得到了
log before it sends out append entries
and maybe the append entry RPC only got

786
01:11:32,380 --> 01:11:36,160
到服务器2，所以这种情况就像最简单的情况一样， 
to server 2 so this situation you know
it's like the simplest situation and was

787
01:11:36,160 --> 01:11:43,480
实际上，日志没有什么不同，我们知道它可能如何产生， 
actually the logs are not different and
we know how it could possibly arise and

788
01:11:43,480 --> 01:11:46,480
因此，如果现在发生领导崩溃的服务器3，您就知道下一台服务器
so if server 3 which is a leadership
crash now you know the next server

789
01:11:46,480 --> 01:11:54,820
他们将需要首先确保服务器1正常运行，如果服务器3崩溃或
they're gonna need to make sure server 1
well first of all if server 3 crashes or

790
01:11:54,820 --> 01:11:57,790
我们将参加选举，某些领导者被选中，你知道两件事
we'll be at an election and some of the
leader is chosen you know two things

791
01:11:57,790 --> 01:12:04,990
必须发生新领导人必须认识到该命令可能
have to happen the new leader has got to
recognize that this command could have

792
01:12:04,990 --> 01:12:07,750
承诺不允许扔掉它
committed it's not allowed to throw it
away

793
01:12:07,750 --> 01:12:12,070
并且需要确保服务器一号确实在此处填充了此空白
and it needs to make sure server one
fills in this blank here with indeed

794
01:12:12,070 --> 01:12:17,950
其他人在那个插槽中都拥有的同样的命令
this very same command that everybody
else had in that slot all right so after

795
01:12:17,950 --> 01:12:22,420
您认识的服务器3崩溃的人可能会想到的另一种方法是
a crash somebody you know server 3
suppose another way this can come up is

796
01:12:22,420 --> 01:12:26,140
服务器3可能已经向服务器2发送了附加条目，但是随后崩溃了
server 3 might have sent out the append
entries the server 2 but then crashed

797
01:12:26,140 --> 01:12:30,400
在将附加条目发送到服务器3之前，如果您知道选择一个
before sending the append entries to
server 3 so if were you know electing a

798
01:12:30,400 --> 01:12:34,530
新的领导者，这可能是因为在发送消息之前发生了崩溃
new leader it could because we got a
crash before the message was sent

799
01:12:34,530 --> 01:12:44,830
这是再次考虑三台服务器的另一种情况，不，我是说一个数字
here's another scenario to think about
three servers again no I mean a number

800
01:12:44,830 --> 01:12:55,560
法律中的插槽，所以我们可以参考它们，插槽10 11 12 13 
the slots in the law and so we can refer
to them got slot 10 11 12 13

801
01:12:55,730 --> 01:13:04,360
 [音乐]再次是相同的设置，除了现在我们有
[Music]
again it's same setup except now we have

802
01:13:04,360 --> 01:13:11,170
在幻灯片12中，我们将服务器2作为术语的命令，而服务器3具有一个
in slide 12 we have server 2 as a
command from term for and server 3 has a

803
01:13:11,170 --> 01:13:14,730
第5学期的学期命令
term command from term 5

804
01:13:15,790 --> 01:13:21,470
因此，在我们分析这些信息以了解会发生什么以及发生什么之前
so you know before we analyze these to
figure out what would happen and what

805
01:13:21,470 --> 01:13:24,980
如果服务器看到它，我们会问这是否可能发生，因为
would a server do if it saw this we need
to ask could this even occur because

806
01:13:24,980 --> 01:13:28,520
有时候这个问题的答案哦，哎呀，如果这会发生什么
sometimes the answer to the question oh
jeez what would happen if this

807
01:13:28,520 --> 01:13:32,900
有时会出现配置问题，答案是它不可能出现，所以我们不必
configuration arose sometimes the answer
is it cannot arise so we do not have to

808
01:13:32,900 --> 01:13:39,940
担心它的问题是这会发生吗？ 
worry about it the question is could
this arise and how

809
01:13:57,900 --> 01:14:02,990
好吧，任何
all right so any

810
01:14:12,820 --> 01:14:15,910
 [音乐] 
[Music]

811
01:14:52,659 --> 01:14:55,659
是的
yeah

812
01:14:59,060 --> 01:15:05,670
简而言之，我们知道这种配置会出现，因此我们可以
in brief we know this configuration can
arise and so the way we can then get the

813
01:15:05,670 --> 01:15:08,910
我们在下一个领导者选举服务器中假设4和5 
four and a five here is let's suppose in
the next leader election server twos

814
01:15:08,910 --> 01:15:13,440
当选领导人现任其当选领导人，因为
elected leader now for term for its
elected leader because a request from a

815
01:15:13,440 --> 01:15:20,040
客户端将其附加到自己的日志中并崩溃，因此现在我们拥有此权限
client it appends it to its own log and
crashes so now we have this right we

816
01:15:20,040 --> 01:15:25,410
需要新的选举，因为领导者在这次选举中刚刚崩溃
need a new election because the leader
just crashed now in this election and

817
01:15:25,410 --> 01:15:29,370
那么现在我们必须问谁可以当选还是我们必须给他
then so now we have to ask whether who
could be elected or we have to give him

818
01:15:29,370 --> 01:15:32,730
哦，天哪，可以当选什么，所以我们要索要服务器
back of our heads oh gosh what could be
elected so we're gonna claim server

819
01:15:32,730 --> 01:15:35,760
三个人可以当选我之所以可以当选是因为
three could be elected the reason why I
could be elected is because it only

820
01:15:35,760 --> 01:15:40,500
需要多数的请求投票答复，多数是服务器一，并且
needs request vote responses from
majority that majority is server one and

821
01:15:40,500 --> 01:15:44,370
服务器三，你知道这两个之间没有冲突没有问题
server three you know there's no no
problem no conflict between these two

822
01:15:44,370 --> 01:15:48,770
记录日志，以便可以为第五任选出第三服务器
logs so server three can be elected for
term five get a request from a client

823
01:15:48,770 --> 01:15:54,180
将其附加到自己的日志中并崩溃，这就是您获得此信息的方式
append it to its own log and crash and
that's how you get this this

824
01:15:54,180 --> 01:16:04,140
配置，因此您知道您需要能够完成这些工作
configuration so you know you need to be
able to to work through these things in

825
01:16:04,140 --> 01:16:07,140
为了到达说是的阶段，这可能会发生，因此漂流
order to get to the stage of saying yes
this could happen and therefore raft

826
01:16:07,140 --> 01:16:11,310
必须做一些明智的事情，而不是做某事，因为某些事情
must do something sensible as opposed to
it cannot happen because some things

827
01:16:11,310 --> 01:16:13,730
不可能发生
can't happen

828
01:16:17,539 --> 01:16:27,050
好吧，所以现在发生了什么，我们知道这会发生，所以希望我们可以
all right so so what can happen now we
know this can occur so hopefully we can

829
01:16:27,050 --> 01:16:34,550
说服自己，筏现在确实做了一些明智的事情， 
convince ourselves that raft actually
does something sensible now as for the

830
01:16:34,550 --> 01:16:39,860
在我们讨论英国皇家空军实际上将要做什么之前
range of things before we talk about
what RAF would actually would actually

831
01:16:39,860 --> 01:16:48,489
我们是否需要对可以接受的结果权利有所了解？ 
do we need to have some sense of what
would be an acceptable outcome right and

832
01:16:48,489 --> 01:16:55,190
我们只知道插槽10中的命令，因为
just eyeballing this we know that the
command in slot 10 since it's known by

833
01:16:55,190 --> 01:17:01,610
它可能已经提交的所有副本，因此我们不能将其丢弃
all all the replicas it could have been
committed so we cannot throw it away

834
01:17:01,610 --> 01:17:05,659
与插槽11中的命令类似，因为它在大多数副本中
similarly the command in slot 11 since
it's in a majority of the replicas it

835
01:17:05,659 --> 01:17:09,380
对于我们所知道的所有已经承诺的事情，我们不能将其扔掉
could for all we know have been
committed so we can't throw it away the

836
01:17:09,380 --> 01:17:13,190
 12号插槽中的命令，但是它们都可能未提交
command in slot 12 however neither of
them could possibly have been committed

837
01:17:13,190 --> 01:17:18,739
所以我们有权，我们不知道实际上我们不会，但筏有权
so we're entitled we don't know haven't
we'll actually do but raft is entitled

838
01:17:18,739 --> 01:17:23,480
即使无权删除它们，也可以删除两者
to drop both of these even though it is
not entitled to drop it and either of

839
01:17:23,480 --> 01:17:28,849
 10或11中的命令被删除，不是
the commands in a 10 or 11
this is entitled dropped it's not

840
01:17:28,849 --> 01:17:33,380
需要丢掉其中之一，但是我的意思是，它肯定必须丢掉一个
required to drop either one of them but
I mean oh it certainly must drop one at

841
01:17:33,380 --> 01:17:39,639
至少一个，因为最后必须具有相同的日志内容
least one because you have to have
identical log contents in the end

842
01:17:43,290 --> 01:17:50,100
我们可能无法通过查看法律来判断这一点
this could have been committed it the we
can't tell by looking at the laws

843
01:17:50,100 --> 01:17:55,510
确切地说，领导者在坠毁前走了多远，所以一种可能性是
exactly how far the leader got before
crashing so one possibility is that for

844
01:17:55,510 --> 01:18:00,790
这个命令甚至这个命令的一种可能性是领导者发出
this command or even this command one
possibility is that leaders send out the

845
01:18:00,790 --> 01:18:05,620
使用新命令附加消息，然后立即崩溃，因此它从未
append messages with a new command and
then immediately crashed so it never got

846
01:18:05,620 --> 01:18:09,640
因为它崩溃了，所以没有回音，所以这位老领导人不知道那是不是
any response back because it crashed so
the old leader did not know if it was

847
01:18:09,640 --> 01:18:14,410
提交，如果没有回复，则表示没有
committed and if it didn't get a
response back that means it didn't

848
01:18:14,410 --> 01:18:18,940
执行它并没有发出，但您知道它没有发出
execute it and it didn't send out but
you know it didn't send out that

849
01:18:18,940 --> 01:18:24,610
提交索引增加了，所以也许副本也没有执行它，所以
incremented commit index and so maybe
the replicas didn't execute it either so

850
01:18:24,610 --> 01:18:29,980
实际上很有可能没有提交，即使RAF没有
it's actually possible that this wasn't
committed so even though RAF doesn't

851
01:18:29,980 --> 01:18:40,780
如果筏知道的多于它所知道的，那么就知道筏是合法的
know it could be legal for raft
if raft knew more than it does know it

852
01:18:40,780 --> 01:18:45,040
删除此日志条目可能是合法的，因为它可能尚未提交
might be legal to drop this log entry
because it might not have been committed

853
01:18:45,040 --> 01:18:51,010
但是因为没有证据可以证明它是基于事实的
but because on the evidence there's no
way to disprove it was committed based

854
01:18:51,010 --> 01:18:55,300
根据这个证据，它可能已经犯了，筏不能证明它不是
on this evidence it could have been
committed and raft can't prove it wasn't

855
01:18:55,300 --> 01:19:01,060
因此它必须将其视为已落实，因为领导者可能已收到它
so it must treat it as committed because
the leader might have received it might

856
01:19:01,060 --> 01:19:05,620
在收到附加条目回复并回复到
have crashed just after receiving the
append entry replies and replying to the

857
01:19:05,620 --> 01:19:10,600
客户，所以仅查看此内容就不能排除
client so just looking at this we can't
rule out the possibility that either

858
01:19:10,600 --> 01:19:15,790
领导者回应客户的可能性，在这种情况下我们不能丢
possibility that the leader responded to
the client in which case we cannot throw

859
01:19:15,790 --> 01:19:18,969
拒绝此条目，因为客户知道它或领导者的可能性
away this entry because a client knows
about it or the possibility the leader

860
01:19:18,969 --> 01:19:26,670
没做过，是的，我们可以知道是否必须假定它已提交吗？ 
never did and yeah we could you know if
we have to assume that it was committed

861
01:19:33,390 --> 01:19:36,390
是的
yeah

862
01:19:46,489 --> 01:19:53,630
不，没有mañana服务器崩溃，在得到响应之前还可以
no there's no mañana server crash before
getting the response it's alright well

863
01:19:53,630 --> 01:19:58,360
让我们在星期四继续
let's continue this on Thursday

