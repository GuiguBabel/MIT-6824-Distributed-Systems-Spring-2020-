1
00:00:00,800 --> 00:00:11,820
好吧，让我们开始吧，这是分布式系统的682，所以
all right let's get started
this is 682 for distributed systems so

2
00:00:11,820 --> 00:00:14,639
我想先简要说明一下我认为
I'd like to start with just a brief
explanation of what I think a

3
00:00:14,639 --> 00:00:21,630
您知道分布式系统的核心是一组协作计算机
distributed system is you know the core
of it is a set of cooperating computers

4
00:00:21,630 --> 00:00:26,190
通过网络相互通信以获得一些连贯的*
that are communicating with each other
over networked to get some coherent task

5
00:00:26,190 --> 00:00:31,530
完成，因此我们将在本课程中重点介绍的各种示例
done and so the kinds of examples that
we'll be focusing on in this class are

6
00:00:31,530 --> 00:00:38,660
大型网站的存储或MapReduce等大数据计算之类的东西
things like storage for big websites or
big data computations such as MapReduce

7
00:00:38,660 --> 00:00:43,950
还有一些更奇特的事情，例如点对点文件共享
and also somewhat more exotic things
like peer-to-peer file sharing so

8
00:00:43,950 --> 00:00:48,329
它们只是示例，我们将研究各种案例研究， 
they're all just examples the kinds of
case studies we'll look at and the

9
00:00:48,329 --> 00:00:51,600
所有这些都很重要的原因是，许多重要的基础设施
reason why all this is important is that
a lot of critical infrastructure out

10
00:00:51,600 --> 00:00:56,250
分布式系统基础架构的建立需要
there is built out of distributed
systems infrastructure that requires

11
00:00:56,250 --> 00:00:59,579
一台以上的计算机来完成工作，或者它本身就需要
more than one computer to get its job
done or it's sort of inherently needs to

12
00:00:59,579 --> 00:01:06,300
被分散在身体上，所以人们为什么要建造这些东西的原因是
be spread out physically so the reasons
why people build this stuff so first of

13
00:01:06,300 --> 00:01:10,500
在我谈论分布式系统之前，所有这些都提醒您您知道
all before I even talk about distributed
systems sort of remind you that you know

14
00:01:10,500 --> 00:01:14,280
如果要重新设计系统，则需要解决一些问题
if you're designing a system redesigning
you need to solve some problem if you

15
00:01:14,280 --> 00:01:18,570
可以在您知道的单台计算机上解决该问题，而无需构建
can possibly solve it on a single
computer you know without building a

16
00:01:18,570 --> 00:01:23,340
分布式系统，您应该采用这种方式，并且可以完成很多工作
distributed system you should do it that
way and there's many many jobs you can

17
00:01:23,340 --> 00:01:29,220
在一台计算机上完成工作，这总是更容易，所以分布式系统
get done on a single computer and it's
always easier so distributed systems you

18
00:01:29,220 --> 00:01:32,400
知道在尝试构建分布式系统之前，您应该尝试其他所有方法
know you should try everything else
before you try building distributed

19
00:01:32,400 --> 00:01:36,630
系统，因为它们不是，它们并不简单，所以人们之所以成为
systems because they're not they're not
simpler so the reason why people are

20
00:01:36,630 --> 00:01:41,640
被驱使使用许多合作计算机，他们需要
driven to use lots of cooperating
computers are they need to get

21
00:01:41,640 --> 00:01:45,180
高性能和思考方式是他们希望获得成就
high-performance and the way to think
about that is they want to get achieve

22
00:01:45,180 --> 00:01:52,409
某种并行性很多CPU很多内存很多磁盘臂
some sort of parallelism lots of CPUs
lots of memories lots of disk arms

23
00:01:52,409 --> 00:01:58,290
平行移动人们建造这些东西的另一个原因是能够
moving in parallel another reason why
people build this stuff is to be able to

24
00:01:58,290 --> 00:02:01,070
容错
tolerate faults

25
00:02:05,310 --> 00:02:09,580
如果两台计算机中的其中一台发生故障，您可以做两件事
have two computers do the exact same
thing if one of them fails you can cut

26
00:02:09,580 --> 00:02:15,070
彼此之间是，一些问题只是自然而然地传播
over to the other one another is that
some problems are just naturally spread

27
00:02:15,070 --> 00:02:19,420
像您知道要在银行间进行资金转帐或
out in space like you know you want to
do interbank transfers of money or

28
00:02:19,420 --> 00:02:23,980
事情很好，您知道银行a在纽约市有这台计算机，而银行B在
something well you know bank a has this
computer in New York City and Bank B as

29
00:02:23,980 --> 00:02:27,790
伦敦的这台计算机，您知道您只需为他们提供一些方式
this computer in London you know you
just have to have some way for them to

30
00:02:27,790 --> 00:02:31,330
互相交谈并合作以实现目标，所以有一些
talk to each other and cooperate in
order to carry that out so there's some

31
00:02:31,330 --> 00:02:37,360
一种自然的物理原因系统，其固有地在物理上
natural sort of physical reasons systems
that are inherently physically

32
00:02:37,360 --> 00:02:42,040
分发的原因是人们建造此产品的最终目的是为了
distributed for the final reason that
people build this stuff is in order to

33
00:02:42,040 --> 00:02:46,660
经常通过某种代码来实现某种安全目标
achieve some sort of security goal so
often by if there's some code you don't

34
00:02:46,660 --> 00:02:50,920
信任，或者您知道您需要与某人互动，但您知道他们可能不需要
trust or you know you need to interact
with somebody but you know they may not

35
00:02:50,920 --> 00:02:55,420
立即成为恶意软件，或者他们的代码中包含错误，因此您不想
be immediate malicious or maybe their
code has bugs in it so you don't want to

36
00:02:55,420 --> 00:02:59,350
必须信任它，您可能想拆分计算，以便您知道自己的
have to trust it you may want to split
up the computation so you know your

37
00:02:59,350 --> 00:03:02,500
东西在那里运行，那台计算机我的东西在这台计算机上运行， 
stuff runs over there and that computer
my stuff runs here on this computer and

38
00:03:02,500 --> 00:03:06,580
他们只与某种狭窄的狭窄定义的网络互相交谈
they only talk to each other to some
sort of narrow narrowly defined network

39
00:03:06,580 --> 00:03:13,570
协议，假设我们可能担心您知道安全性，那就是
protocol assuming we may be worried
about you know security and that's

40
00:03:13,570 --> 00:03:16,420
通过将事物拆分成多台计算机来实现
achieved by splitting things up into
multiple computers so that they can be

41
00:03:16,420 --> 00:03:23,920
孤立本课程的大部分将与性能和故障有关
isolated the most of this course is
going to be about performance and fault

42
00:03:23,920 --> 00:03:28,630
宽容，尽管其他两个人通常以某种方式
tolerance although the other two often
work themselves in by way of the sort of

43
00:03:28,630 --> 00:03:32,799
我们要看的案例研究的约束条件
constraints on the case studies that
we're going to look at you know all

44
00:03:32,799 --> 00:03:36,430
这些分布式系统，所以这些问题是因为它们有很多
these distributed systems so these
problems are because they have many

45
00:03:36,430 --> 00:03:42,220
零件和零件同时执行，因为您有多台计算机
parts and the parts execute concurrently
because there are multiple computers you

46
00:03:42,220 --> 00:03:45,190
解决并发编程带来的所有问题
get all the problems that come up with
concurrent programming all the sort of

47
00:03:45,190 --> 00:03:49,660
复杂的交互，我们是时间相关的东西，这是一部分
complex interactions and we're
timing-dependent stuff and that's part

48
00:03:49,660 --> 00:03:54,340
是什么使分布式系统变得困难？ 
of what makes distributed systems hard
another thing that makes distributed

49
00:03:54,340 --> 00:03:59,410
系统之所以难，是因为您又拥有多个组件和一个网络， 
systems hard is that because again you
have multiple pieces plus a network you

50
00:03:59,410 --> 00:04:04,540
可能有非常意外的故障模式，即如果您有一个
can have very unexpected failure
patterns that is if you have a single

51
00:04:04,540 --> 00:04:08,350
计算机，通常情况是计算机可以正常工作，或者崩溃或
computer it's usually the case either
computer works or maybe it crashes or

52
00:04:08,350 --> 00:04:12,280
遭受电源故障或某些故障，但几乎可以正常工作或无效
suffers a power failure or something but
it pretty much either works or doesn't

53
00:04:12,280 --> 00:04:15,940
由许多计算机组成的工作分布式系统，您可以部分
work distributed systems made up of lots
of computers you can have partial

54
00:04:15,940 --> 00:04:20,140
某些零件的故障使其他人无法工作
failures that is some pieces stopped
working other people other pieces

55
00:04:20,140 --> 00:04:24,280
继续工作，或者计算机正在工作，但是网络的某些部分
continue working or maybe the computers
are working but some part of the network

56
00:04:24,280 --> 00:04:30,870
损坏或不可靠，因此部分故障是另一个原因
is broken or unreliable so partial
failures is another reason why

57
00:04:30,870 --> 00:04:51,880
分布式系统很难，而造成这种困难的最后一个原因是您知道
distributed systems are hard and a final
reason why it's hard is that you know

58
00:04:51,880 --> 00:04:54,780
他们构建分布式系统的最初原因通常是
them the original reason to build the
distributed system is often to get

59
00:04:54,780 --> 00:04:59,380
更高的性能让您知道一千台计算机的性能价值
higher performance to get you know a
thousand computers worth of performance

60
00:04:59,380 --> 00:05:03,580
或一千个磁盘臂的性能，但实际上
or a thousand disk arms were the
performance but it's actually very

61
00:05:03,580 --> 00:05:09,310
要获得一千台计算机来加速一千个X的速度，将非常棘手
tricky to obtain that thousand X speed
up with a thousand computers there's

62
00:05:09,310 --> 00:05:20,080
通常会有很多路障挡在您的路上，所以精灵需要小心一点
often a lot of roadblocks thrown in your
way so the Elven takes a bit of careful

63
00:05:20,080 --> 00:05:24,270
设计使系统真正为您提供应有的性能
design to make the system actually give
you the performance you feel you deserve

64
00:05:24,270 --> 00:05:27,690
因此，解决这些问题当然将完全取决于您
so solving these problems of course
going to be all about you know

65
00:05:27,690 --> 00:05:33,729
解决这些问题之所以选择本课程，是因为通常
addressing these issues the reason to
take the course is because often the

66
00:05:33,729 --> 00:05:38,320
问题和解决方案在技术上都非常有趣
problems and the solutions are quite
just technically interesting they're

67
00:05:38,320 --> 00:05:42,640
对于其中一些困难的难题，有很好的解决方案，以
hard problems for some of these problems
there's pretty good solutions known for

68
00:05:42,640 --> 00:05:47,740
其他问题不是很好的解决方案现在分布式系统
other problems they're not such great
solutions now distributed systems are

69
00:05:47,740 --> 00:05:53,349
许多现实世界的系统都在使用它，例如经常涉及的大型网站
used by a lot of real-world systems out
there like big websites often involved

70
00:05:53,349 --> 00:05:57,970
你知道大量的计算机，它们分布在一起
you know vast numbers computers that are
you know put together as distributed

71
00:05:57,970 --> 00:06:03,490
我刚开始教这门课程时是分布式系统
systems when I first started teaching
this course it was distributed systems

72
00:06:03,490 --> 00:06:07,659
是一种学术上的好奇心，你知道人们以为你知道
were something of an academic curiosity
you know people thought oh you know at a

73
00:06:07,659 --> 00:06:11,080
有时它们被小规模使用，人们感到哦，总有一天他们会
small scale they were used sometimes and
people felt that oh someday they'd be

74
00:06:11,080 --> 00:06:16,690
可能很重要，但现在特别受巨型网站的兴起所驱动
might be important but now particularly
driven by the rise of giant websites

75
00:06:16,690 --> 00:06:21,960
你知道海量数据和整个装有计算机的仓库
that have you know vast amounts of data
and entire warehouses full of computers

76
00:06:21,960 --> 00:06:25,860
在过去的二十年中，分布式系统已经变得非常
distributed systems in the last
twenty years have gotten to be very

77
00:06:25,860 --> 00:06:32,889
计算基础架构的重要组成部分，这意味着
seriously important part of computing
infrastructure this means that there's

78
00:06:32,889 --> 00:06:36,250
已经引起了他们的很多关注，但已经解决了很多问题，但是
been a lot of attention paid to them a
lot of problems have been solved but

79
00:06:36,250 --> 00:06:39,940
还有很多未解决的问题，所以如果你是一名研究生
there's still quite a few unsolved
problems so if you're a graduate student

80
00:06:39,940 --> 00:06:45,310
或您对研究感兴趣，但您遇到了很多麻烦
or you're interested in research there's
a lot to you let a lot of problems yet

81
00:06:45,310 --> 00:06:49,720
在分布式系统中解决，您可以研究他的研究和
to be solved in distributed systems that
you could look into his research and

82
00:06:49,720 --> 00:06:54,220
最后，如果您喜欢建造东西，这是一个很好的课程，因为它有一个实验室
finally if you like building stuff this
is a good class because it has a lab

83
00:06:54,220 --> 00:06:58,690
您将构建一些相当现实的分布式系统的顺序
sequence in which you'll construct some
fairly realistic distributed systems

84
00:06:58,690 --> 00:07:01,180
专注于性能和容错
focused on performance and fault
tolerance

85
00:07:01,180 --> 00:07:06,789
所以你有很多练习建筑区，只是建筑分布
so you've got a lot of practice building
districts just building distributed

86
00:07:06,789 --> 00:07:12,419
系统并使它们正常运行，让我稍微谈谈课程结构
systems and making them work all right
let me talk about course structure a bit

87
00:07:12,419 --> 00:07:19,060
在我开始真正的技术内容之前，您应该能够找到
before I get started on real technical
content you should be able to find the

88
00:07:19,060 --> 00:07:24,820
使用Google的课程网站，在课程网站上是实验室作业
course website using Google and on the
course website is the lab assignments

89
00:07:24,820 --> 00:07:31,210
和课程表，还链接到广场页面，您可以在其中发布问题
and course schedule and also link to a
Piazza page where you can post questions

90
00:07:31,210 --> 00:07:36,970
得到答案课程人员我是Robert Morris我将讲课
get answers the course staff I'm Robert
Morris I'll be giving the lectures I

91
00:07:36,970 --> 00:07:44,349
你们也想站起来展示自己的脸，TAS也有
also have for TAS you guys want to stand
up and show your faces the TAS are

92
00:07:44,349 --> 00:07:49,690
特别是在解决他们将要举行的实验室方面的专家
experts at in particular at doing the
solving the labs they'll be holding

93
00:07:49,690 --> 00:07:53,080
办公时间，所以如果您对实验室有疑问，可以来
office hours so if you have questions
about the labs you can come you should

94
00:07:53,080 --> 00:07:59,650
去上班时间，或者您可以向广场发表问题，课程内容包括
go to office hours or you could post
questions to Piazza the course has a

95
00:07:59,650 --> 00:08:09,099
几个重要的组成部分之一是本次讲座，几乎有一篇论文
couple of important components one is
this lectures there's a paper for almost

96
00:08:09,099 --> 00:08:16,380
每堂课都有两次考试
every lecture there's two exams

97
00:08:17,789 --> 00:08:25,479
有实验室编程实验室，还有一个可选的最终项目， 
there's the labs programming labs and
there's an optional final project that

98
00:08:25,479 --> 00:08:28,740
您可以代替实验室之一
you can do instead of one of the labs

99
00:08:36,039 --> 00:08:42,070
讲座将涉及分布式系统中的两个重要思想，它们也将是
the lectures will be about two big ideas
in distributed systems they'll also be a

100
00:08:42,070 --> 00:08:47,140
一些关于实验室编程的讲座，很多
couple of lectures that are more about
sort of lab programming stuff a lot of

101
00:08:47,140 --> 00:08:50,589
我们将通过很多案例研究来开展我们的讲座
our lectures will be taken up by case
studies a lot of the way that I sort of

102
00:08:50,589 --> 00:08:55,210
尝试通过查看带出分布式系统的内容
try to bring out the content of
distributed systems is by looking at

103
00:08:55,210 --> 00:09:01,960
论文，一些学者，一些由行业人士撰写，描述真实
papers some academics some written by
people in industry describing real

104
00:09:01,960 --> 00:09:05,100
解决实际问题的方法
solutions to real problems

105
00:09:05,589 --> 00:09:10,270
这些讲座实际上是录像带，我希望将它们在线发布
these lectures actually be videotaped
and I'm hoping to post them online so

106
00:09:10,270 --> 00:09:15,279
这样，如果您不在这里，或者您想复习讲座，就可以
that you can so if you're not here or
you want to review the lectures you'll

107
00:09:15,279 --> 00:09:20,110
能够再次看录像带讲座的论文，有一个
be able to look at the videotape
lectures the papers again there's one to

108
00:09:20,110 --> 00:09:24,610
每周阅读大部分研究论文，其中一些是经典论文，例如
read per week most of a research paper
some of them are classic papers like

109
00:09:24,610 --> 00:09:28,390
今天的论文，我希望你们中的一些人已经在MapReduce上阅读过
today's paper which I hope some of you
have read on MapReduce it's an old paper

110
00:09:28,390 --> 00:09:33,310
但这是它激发了大量有趣工作的开始
but it was the beginning of its spurred
an enormous amount of interesting work

111
00:09:33,310 --> 00:09:37,029
无论是学术界还是现实世界，都有些经典，有些则更多
both academic and in the real world so
some are classic and some are more

112
00:09:37,029 --> 00:09:41,500
最近的论文都在谈论更多有关人的最新研究
recent papers sort of talking about more
up-to-date research what people are

113
00:09:41,500 --> 00:09:46,060
目前很担心，从报纸上我们希望能弄明白什么
currently worried about and from the
papers we'll be hoping to tease out what

114
00:09:46,060 --> 00:09:50,529
基本的问题是人们有哪些想法可能会或可能不会
the basic problems are what ideas people
have had that might or might not be

115
00:09:50,529 --> 00:09:54,970
在解决分布式系统问题中很有用，我们有时会看
useful in solving distributed system
problems we'll be looking at sometimes

116
00:09:54,970 --> 00:09:58,720
这些论文中有一些实施细节，因为其中很多
in implementation details in some of
these papers because a lot of this has

117
00:09:58,720 --> 00:10:03,430
与基于软件的系统的实际构建有关，我们也
to do with actual construction of of
software based systems and we're also

118
00:10:03,430 --> 00:10:07,540
要花一些时间看评估人们评估故障的程度
going to spend a certain time looking at
evaluations people evaluating how fault

119
00:10:07,540 --> 00:10:11,200
通过衡量他们或人们衡量多少性能来容忍他们的系统
tolerant their systems by measuring them
or people measuring how much performance

120
00:10:11,200 --> 00:10:17,950
还是他们根本没有提高性能，所以我希望
or whether they got performance
improvement at all so I'm hoping that

121
00:10:17,950 --> 00:10:22,660
您上课之前会先阅读论文，演讲可能不会进行
you'll read the papers before coming to
class the lectures are maybe not going

122
00:10:22,660 --> 00:10:26,110
如果您还没有阅读过该讲义，那将是非常有意义的，因为
to make as much sense if you haven't
already read the lecture because there's

123
00:10:26,110 --> 00:10:30,820
没有足够的时间来解释论文的所有内容并进行整理
not enough time to both explaining all
the content of the paper and have a sort

124
00:10:30,820 --> 00:10:35,050
对本文对在线课堂的意义进行了有趣的思考，所以您真的
of interesting reflection on what the
paper means online class so you really

125
00:10:35,050 --> 00:10:38,620
在上课之前必须先阅读论文，希望其中之一
got to read the papers before I come
into class and hopefully one of the

126
00:10:38,620 --> 00:10:42,470
您将在本课程中学习的内容是如何在鱼中快速阅读论文
things you'll learn in this class is how
to read a paper rapidly in the fish

127
00:10:42,470 --> 00:10:47,430
并跳过那些可能不那么重要和关注的部分
and skip over the parts that maybe
aren't that important and sort of focus

128
00:10:47,430 --> 00:10:53,730
在网站上发布重要想法时，每个链接都有
on teasing out the important ideas on
the website there's for every link to

129
00:10:53,730 --> 00:10:59,160
购买时间表，有一个问题，您应该为此提交答案
buy the schedule there's a question that
you should submit an answer for for

130
00:10:59,160 --> 00:11:02,790
我认为每篇论文的答案都应该在午夜到期，我们也请您
every paper I think the answers are due
at midnight and we also ask that you

131
00:11:02,790 --> 00:11:08,070
通过网站同时提交您对论文的问题
submit a question you have about the
paper through the website in order both

132
00:11:08,070 --> 00:11:11,280
在准备讲座时以及如果有的话给我一些思考的地方
to give me something to think about as
I'm preparing the lecture and if I have

133
00:11:11,280 --> 00:11:17,280
时间，我将尝试通过电子邮件和至少回答一些问题
time I'll try to answer at least a few
of the questions by email and the

134
00:11:17,280 --> 00:11:22,140
每个论文的前一天晚上午夜应有的问题和答案
question and the answer for each paper
due midnight the night before there's

135
00:11:22,140 --> 00:11:26,850
两次考试我上次课堂会议上有一个期中考试
two exams there's a midterm exam in
class I think on the last class meeting

136
00:11:26,850 --> 00:11:36,000
在春假之前，并且在期末考试的最后一周有期末考试
before spring break and there's a final
exam during final exam week at the end

137
00:11:36,000 --> 00:11:42,120
这学期的考试主要集中在试卷和实验室
of the semester the exams are going to
focus mostly on papers and the labs and

138
00:11:42,120 --> 00:11:46,320
可能是为他们做准备以及参加讲座和培训的最好方法
probably the best way to prepare for
them as well as attending lecture and

139
00:11:46,320 --> 00:11:51,360
阅读试卷准备考试的一种好方法是查看我们所有的考试
reading the papers a good way to prepare
for the exams is to look at all exams we

140
00:11:51,360 --> 00:11:57,240
与20年的旧考试和解决方案相关联，因此您可以查看这些内容和
have links to 20 years of old exams and
solutions and so you look at those and

141
00:11:57,240 --> 00:12:01,350
感觉到我想问什么样的问题，确实
sort of get a feel for what kind of
questions that I like to ask and indeed

142
00:12:01,350 --> 00:12:05,550
因为我们不可避免地会阅读许多相同的论文，每年我都会提出问题
because we read many of the same papers
inevitably I ask questions each year

143
00:12:05,550 --> 00:12:15,420
就像过去几年实验室里提出的问题一样
that can't help but resemble questions
asked in previous years the labs there's

144
00:12:15,420 --> 00:12:25,650
对于编程实验室，其中第一个实验室应在下周星期五进行。 
for programming labs the first one of
them is due Friday next week lab one is

145
00:12:25,650 --> 00:12:33,810
一个简单的MapReduce实验室，以实现您自己编写的论文版本
a simple MapReduce lab to implement your
own version of the paper they write

146
00:12:33,810 --> 00:12:36,050
今天，我将在几分钟内讨论
today in which I'll be discussing in a
few minutes

147
00:12:36,050 --> 00:12:43,620
实验2涉及使用一种称为“筏”的技术，以获取在
lab 2 involves using a technique called
raft in order to get fault taught in

148
00:12:43,620 --> 00:12:49,680
为了在理论上允许某种排序，允许通过以下方式使任何系统容错
order to sort of allow in theory allow
any system to be made fault tolerant by

149
00:12:49,680 --> 00:12:53,850
复制并使用此筏技术管理复制和
replicating it and having this raft
technique manage the replication and

150
00:12:53,850 --> 00:12:57,660
管理某种类型的自动剪切，或者如果其中一个
manage sort of automatic cut
or if there's a field if one of the

151
00:12:57,660 --> 00:13:08,700
复制的服务器发生故障，因此这是小伙子3中的rav4容错能力，您将使用
replicated servers fails so this is rav4
fault tolerance in lad 3 you'll use your

152
00:13:08,700 --> 00:13:18,990
筏实施以构建容错键值服务器
raft implementation in order to build a
fault tolerant key-value server it'll be

153
00:13:18,990 --> 00:13:25,950
在实验室4中进行复制并具有容错能力，您将获得复制的键值
replicated and fault tolerant in a lab 4
you'll take your replicated key-value

154
00:13:25,950 --> 00:13:30,390
服务器并将其克隆到多个独立的组中，然后将
server and clone it into a number of
independent groups and you'll split the

155
00:13:30,390 --> 00:13:35,160
所有这些个人中的键值存储系统中的数据
data in your key value storage system
across all of these individual

156
00:13:35,160 --> 00:13:39,660
复制的组以通过运行多个复制得到并行加速
replicated groups to get parallel
speed-up by running multiple replicated

157
00:13:39,660 --> 00:13:47,790
并行分组，您还将负责移动各种
groups in parallel and you'll also be
responsible for moving the various

158
00:13:47,790 --> 00:13:52,500
不同服务器之间来来去去的大量数据而不会丢失任何数据
chunks of data between different servers
as they come and go without dropping any

159
00:13:52,500 --> 00:14:03,330
球，这就是通常所说的分片键值服务分片
balls so this is a what's often called a
sharded key value service sharding

160
00:14:03,330 --> 00:14:07,410
指拆分数据，将数据划分为多个
refers to splitting up the data
partitioning the data among multiple

161
00:14:07,410 --> 00:14:16,610
服务器，以获取并行速度（如果需要），而不是进行实验4 
servers in order to get parallel speed
up if you want instead of doing lab 4

162
00:14:16,610 --> 00:14:21,480
您可以做一个自己选择的项目，这里的想法是，如果您有一些
you can do a project of your own choice
and the idea here is if you have some

163
00:14:21,480 --> 00:14:26,010
您知道的一些分布式系统风格的分布式系统构想
idea for a distributed system you know
in the style of some of the distributed

164
00:14:26,010 --> 00:14:28,530
如果您有自己的想法要在课堂上讨论的系统
systems we talked about in the class if
you have your own idea that you want to

165
00:14:28,530 --> 00:14:32,100
追求，您喜欢构建某些东西并衡量它是否按顺序工作
pursue and you like to build something
and measure whether it worked in order

166
00:14:32,100 --> 00:14:38,370
探索你的想法，你可以做一个项目，所以对于一个项目，你会选择
to explore your idea you can do a
project and so for a project you'll pick

167
00:14:38,370 --> 00:14:44,070
一些队友，因为我们要求项目由两个或两个以上的团队完成
some teammates because we require that
projects are done in teams of two or

168
00:14:44,070 --> 00:14:49,050
三个人，就像一些队友一样，将您的项目构想发送给我们，我们将
three people so like some teammates and
send your project idea to us and we'll

169
00:14:49,050 --> 00:14:53,580
想一想，说是或否，也许给你一些建议，然后如果
think about it and say yes or no and
maybe give you some advice and then if

170
00:14:53,580 --> 00:14:56,610
您继续进行，如果我们同意，您想做一个项目，那么您会做
you go ahead and do if we say yes and
you want to do a project you do that and

171
00:14:56,610 --> 00:15:00,870
而不是实验4，这是在学期末完成的，你知道你会的
instead of lab 4 and it's due at the end
of the semester and you know you'll you

172
00:15:00,870 --> 00:15:06,960
应该做一些设计工作并建立一个真实的系统，然后在
should do some design work and build a
real system and then in the last day of

173
00:15:06,960 --> 00:15:11,370
课堂上，您将演示您的系统以及上交的简短内容
class you'll demonstrate your system
as well as handing in a short sort of

174
00:15:11,370 --> 00:15:17,730
向我们发送有关您的建造情况的书面报告，我在网站上发布了一些
written report to us about what you
built and I posted on the website some

175
00:15:17,730 --> 00:15:22,350
一些可能对您有用的想法
some ideas which might or may not be
useful for you to sort of spur thoughts

176
00:15:22,350 --> 00:15:27,690
关于您可能会建立哪些项目，但实际上最好的项目是
about what projects you might build but
really the best projects are one where

177
00:15:27,690 --> 00:15:32,700
你们对这个项目有一个好主意，主意是如果您想
sort of you have a good idea for the
project and the idea is if you want to

178
00:15:32,700 --> 00:15:36,810
做一个项目，您应该选择一个与
do a project you should choose an idea
that's sort of in the same vein as the

179
00:15:36,810 --> 00:15:40,640
本课中讨论的系统
systems that were talked about in this
class

180
00:15:40,640 --> 00:15:46,020
好吧，回到实验室，实验室贪婪的是，我们会为您提供实验室代码
okay back to labs the lab Greed's they
we give you you hand in your lab code

181
00:15:46,020 --> 00:15:49,710
我们针对它进行了一些测试，根据数量多少，您早就很棒
and we run some tests against it and
you're great early based on how many

182
00:15:49,710 --> 00:15:55,170
您通过的测试，我们会为您提供所有我们使用的测试，而不是隐藏测试，因此如果
tests you pass we give you all the tests
that we use those no hidden tests so if

183
00:15:55,170 --> 00:15:58,950
您实施了实验室，并且该实验室可靠地通过了所有测试， 
you implement the lab and it reliably
passes all the tests and chances are

184
00:15:58,950 --> 00:16:02,310
除非有有趣的事情发生，否则有时会很好
good unless there's something funny
going on which there sometimes is

185
00:16:02,310 --> 00:16:06,060
如果您的鸡舍在运行时通过了所有测试，则很有可能
chances are good that if you your coop
passes all the tests when you run it or

186
00:16:06,060 --> 00:16:10,320
通过所有测试，您将获得4分的满分，因此
pass all the tests when we run it and
you'll get a four score full score so

187
00:16:10,320 --> 00:16:13,830
希望对您可能获得的分数没有任何神秘感
hopefully there'll be no mystery about
what score you're likely to get on the

188
00:16:13,830 --> 00:16:21,930
实验室让我警告您，调试这些实验室可能很耗时，因为
labs let me warn you that debugging
these labs can be time-consuming because

189
00:16:21,930 --> 00:16:26,820
他们是分布式系统，很多并发和通信
they're distributed systems and a lot of
concurrency and communication sort of

190
00:16:26,820 --> 00:16:34,020
奇怪的难以调试的错误可能会出现，因此您真的应该开始
strange difficult to debug errors can
crop up so you really ought to start the

191
00:16:34,020 --> 00:16:39,210
如果您被淘汰到最后，那么早期的实验室甚至不会带来很多麻烦
labs early don't don't even have a lot
of trouble if you be elapsed to the last

192
00:16:39,210 --> 00:16:43,680
如果您有问题，请尽早开始，请到TAS办公室
moment you got to start early if your
problems please come to the TAS office

193
00:16:43,680 --> 00:16:49,080
小时，请随时问有关广场和
hours and please feel free to ask
questions about the labs on Piazza and

194
00:16:49,080 --> 00:16:52,770
的确，我希望如果您知道答案，您将回答人们的问题。 
indeed I hope if you know the answer
that you'll answer people's questions on

195
00:16:52,770 --> 00:17:04,760
广场也可以解决有关课程机制的任何问题，是的
Piazza as well all right any questions
about the mechanics of the course yes

196
00:17:10,339 --> 00:17:15,329
所以问题是，这些因素如何影响不同因素
so the question is what is how does how
do the different factor these things

197
00:17:15,329 --> 00:17:20,180
考虑到我忘记的成绩，但这一切都在网站的下面
factoring the grade I forget but it's
all on the it's on the website under

198
00:17:20,180 --> 00:17:29,570
我认为虽然这是实验室中最重要的部分
something I think though it's the labs
are the single most important component

199
00:17:29,570 --> 00:17:39,780
好的，这是一门有关应用程序基础结构的课程
okay alright so this is a course about
about infrastructure for applications

200
00:17:39,780 --> 00:17:42,809
因此，在本课程中，我将以某种方式分裂
and so all through this course there's
going to be a sort of split in the way I

201
00:17:42,809 --> 00:17:47,550
谈论应用程序之间的事情，这些人是其他人
talk about things between applications
which are sort of other people the

202
00:17:47,550 --> 00:17:51,390
客户别人写的，但应用程序将使用
customer somebody else writes but the
applications are going to use the

203
00:17:51,390 --> 00:17:55,740
我们在本课程中正在考虑的基础设施以及
infrastructure that we're thinking about
in this course and so the kinds of

204
00:17:55,740 --> 00:18:13,620
基础架构往往会涉及到我们的存储通信和
infrastructure that tend to come up a
lot our storage communication and

205
00:18:13,620 --> 00:18:19,050
计算，我们将讨论提供所有这三种类型的系统
computation and we'll talk about systems
that provide all three of these kinds of

206
00:18:19,050 --> 00:18:24,900
基础架构的存储，事实证明，存储将成为一个
infrastructure the the storage it turns
out that storage is going to be the one

207
00:18:24,900 --> 00:18:30,980
我们最关注的是因为它是定义非常明确且有用的抽象， 
we focus most on because it's a very
well-defined and useful abstraction and

208
00:18:30,980 --> 00:18:34,320
通常是相当简单的抽象，所以人们了解很多
usually fairly straightforward
abstraction so people know a lot about

209
00:18:34,320 --> 00:18:40,350
如何构建如何使用和构建存储系统以及如何构建
how to build how to use and build
storage systems and how to build sort of

210
00:18:40,350 --> 00:18:43,679
复制容错高性能分布式
replicated fault tolerant
high-performance distributed

211
00:18:43,679 --> 00:18:48,720
存储的实现，我们还将讨论一些计算
implementations of storage we'll also
talk about some some of our computation

212
00:18:48,720 --> 00:18:54,750
今天像MapReduce这样的系统是一个计算系统，我们将讨论
systems like MapReduce for today is a
computation system and we will talk

213
00:18:54,750 --> 00:18:58,710
关于沟通的一些，但主要是从角度出发，这是我们需要的工具
about communications some but mostly
from the point is a tool that we need to

214
00:18:58,710 --> 00:19:01,980
用于建立像计算机这样的分布式系统
use to build distributed systems like
computers have to talk to each other

215
00:19:01,980 --> 00:19:06,330
通过网络，您知道您可能需要可靠性或其他一些东西，因此我们会
over a network you know maybe you need
reliability or something and so we'll

216
00:19:06,330 --> 00:19:11,970
谈谈我们实际上主要是通信的使用者，如果您
talk a bit about what we're actually
mostly consumers of communication if you

217
00:19:11,970 --> 00:19:17,040
想要了解通信系统，以了解它们如何工作
want to learn about communication
systems as sort of how they work that's

218
00:19:17,040 --> 00:19:24,750
更多的主题是六个八到九个，因此用于存储和计算的很多
more the topic of six eight to nine
so for storage and computation a lot of

219
00:19:24,750 --> 00:19:31,620
我们的目标是能够发现使用简化的抽象
our goal is to be able to discover
abstractions where use of simplifying

220
00:19:31,620 --> 00:19:36,660
这两个存储和计算分布式存储的接口，以及
the interface to these two storage and
computation distributed storage and

221
00:19:36,660 --> 00:19:40,860
计算基础架构，以便在其之上轻松构建应用程序
computation infrastructure so that it's
easy to build applications on top of it

222
00:19:40,860 --> 00:19:45,270
真正的意思是我们需要我们能够建立
and what that really means is that we
need to we'd like to be able to build

223
00:19:45,270 --> 00:19:51,240
隐藏这些系统的分布式性质的抽象，因此
abstraction that hide the distributed
nature of these of these systems so the

224
00:19:51,240 --> 00:19:56,580
梦想几乎无法完全实现，但梦想是能够建立
dream which is rarely fully achieved but
the dream would be to be able to build

225
00:19:56,580 --> 00:20:00,630
查找应用程序的接口是非分布式的
an interface that looks to an
application is if it's a non distributed

226
00:20:00,630 --> 00:20:03,750
存储系统就像一个文件系统或每个人已经存在的东西
storage system just like a file system
or something that everybody already

227
00:20:03,750 --> 00:20:08,100
知道如何编程，并具有我们很想成为的非常简单的模型语义
knows how to program and has a pretty
simple model semantics we'd love to be

228
00:20:08,100 --> 00:20:13,770
能够构建外观和行为类似于非分布式存储的界面
able to build interfaces that look and
act just like non distributed storage

229
00:20:13,770 --> 00:20:20,370
和计算系统，但实际上您知道巨大的超高性能
and computation systems but are actually
you know vast extremely high performance

230
00:20:20,370 --> 00:20:27,890
下面的容错分布式系统，所以我们都有抽象
fault tolerant distributed systems
underneath so we both have abstractions

231
00:20:30,020 --> 00:20:37,950
而且您知道，随着课程的进行，我们知道您只有一部分
and you know as you'll see as a course
goes on we sort of you know only part of

232
00:20:37,950 --> 00:20:41,820
很少会找到分布式版本的抽象
the way there it's rare that you find an
abstraction for a distributed version of

233
00:20:41,820 --> 00:20:49,110
具有简单行为的存储或计算，但他就像非
storage or computation that has simple
behavior but he's just like the non just

234
00:20:49,110 --> 00:20:52,920
每个人都可以理解但人们得到的非分布式存储版本
non distributed version of storage that
everybody understands but people getting

235
00:20:52,920 --> 00:21:01,680
在这方面更好，我们将尝试研究人们的方式和方法
better at this and we're gonna try to
study the ways and what people have

236
00:21:01,680 --> 00:21:08,760
学会了有关构建这样的抽象的知识，所以是什么样的主题
learned about building such abstractions
ok so what kind of what kind of topics

237
00:21:08,760 --> 00:21:13,590
出现是因为我们正在考虑将这些抽象作为第一个
show up is we're considering these
abstractions the first one this first

238
00:21:13,590 --> 00:21:18,690
常规主题，我们将看到很多我们研究过的系统
topic general topic that we'll see a lot
a lot of the systems we looked at have

239
00:21:18,690 --> 00:21:27,570
与实现有关，例如，您经常看到的那种工具
to do with implementation so for example
the kind of tools that you see a lot for

240
00:21:27,570 --> 00:21:31,650
人们学习如何构建这些系统的方式就是远程过程
for ways people learn how to build these
systems are things like remote procedure

241
00:21:31,650 --> 00:21:35,529
呼叫的目标是掩盖事实
call
whose goal is to mask the fact that

242
00:21:35,529 --> 00:21:44,850
我们正在通过不可靠的网络交流另一种实现方式
we're communicating over an unreliable
Network another kind of implementation

243
00:21:44,850 --> 00:21:51,940
我们将看到很多的主题是线程，这是一种编程技术， 
topic that we'll see a lot is threads
which are a programming technique that

244
00:21:51,940 --> 00:21:56,860
允许我们利用允许我们利用多核计算机的东西，但是也许
allows us to harness what allows us to
harness multi-core computers but maybe

245
00:21:56,860 --> 00:22:00,309
对于此类而言，更重要的是一种构造并发的方法
more important for this class threads
are a way of structuring concurrent

246
00:22:00,309 --> 00:22:06,279
希望可以简化程序员对这些视图的看法
operations in a way that's hopefully
simplifies the programmer view of those

247
00:22:06,279 --> 00:22:10,330
并发操作，并且因为我们要大量使用线程，所以事实证明
concurrent operations and because we're
gonna use threads a lot it turns out

248
00:22:10,330 --> 00:22:13,779
我们还需要从实施级别开始
we're going to need to also you know
just as from an implementation level

249
00:22:13,779 --> 00:22:16,840
花一些时间思考并发控制之类的事情
spend a certain amount of time thinking
about concurrency control things like

250
00:22:16,840 --> 00:22:26,590
锁以及这些实现想法将出现在的主要位置
locks and the main place that these
implementation ideas will come up in the

251
00:22:26,590 --> 00:22:30,190
课堂上，它们会在许多论文中涉及到，但是你会面子
class they'll be touched on in many of
the papers but you're gonna come face

252
00:22:30,190 --> 00:22:34,210
在构建分布式数据库所需的实验室中，这一切的面目都很大
the face of all this in a big way in the
labs you need to build distributed you

253
00:22:34,210 --> 00:22:38,080
知道做分布式系统的编程，这很像
know do the programming for distributed
system and these are like a lot of sort

254
00:22:38,080 --> 00:22:43,659
除了普通的编程之外，您还知道一些重要的工具
of important tools you know beyond just
sort of ordinary programming these are

255
00:22:43,659 --> 00:22:50,279
构建分布式系统所需的一些关键工具
some of the critical tools that you'll
need to use to build distributed systems

256
00:22:50,279 --> 00:22:55,389
我们将要讨论的所有论文中提到的另一个重要主题是
another big topic that comes up in all
the papers we're going to talk about is

257
00:22:55,389 --> 00:23:07,570
性能通常，构建分布式系统的高级目标是
performance usually the high-level goal
of building a distributed system is to

258
00:23:07,570 --> 00:23:17,460
得到人们所谓的可扩展性加速，因此我们正在寻找可扩展性和
get what people call scalable speed-up
so we're looking for scalability and

259
00:23:17,460 --> 00:23:23,529
我所说的可伸缩性或可伸缩加速是指如果我遇到问题
what I mean by scalability or scalable
speed-up is that if I have some problem

260
00:23:23,529 --> 00:23:29,559
我正在用一台计算机解决问题，然后购买了第二台计算机来帮助我执行
that I'm solving with one computer and I
buy a second computer to help me execute

261
00:23:29,559 --> 00:23:34,090
我的问题是，如果我现在可以在一半时间内解决问题，或者也许可以解决
my problem if I can now solve the
problem in half the time or maybe solve

262
00:23:34,090 --> 00:23:39,850
每分钟在两台计算机上知道的问题实例是我在计算机上的两倍
twice as many problem instances you know
per minute on two computers as I had on

263
00:23:39,850 --> 00:23:44,320
那就是可扩展性的一个例子
one then that's an example of
scalability so

264
00:23:44,320 --> 00:23:54,090
你知道计算机或资源让我知道两次
sort of two times you know computers or
resources gets me you know two times

265
00:23:54,090 --> 00:24:02,920
性能或吞吐量，如果您可以构建一个系统，这将是一个巨大的锤子
performance or throughput and this is a
huge hammer if you can build a system

266
00:24:02,920 --> 00:24:07,330
那实际上就是这种行为Namie，如果您增加
that actually has this behavior Namie
that if you increase the number of

267
00:24:07,330 --> 00:24:12,190
您因某种原因而引发问题的计算机，您得到的因素更多
computers you throw at the problem by
some factor you get that factor more

268
00:24:12,190 --> 00:24:17,890
从系统中吞吐更多性能，这是一个巨大的胜利，因为您可以
throughput more performance out of the
system that's a huge win because you can

269
00:24:17,890 --> 00:24:23,410
用钱正确地购买计算机，而如果为了获得
buy computers with just money right
whereas if in order to get the

270
00:24:23,410 --> 00:24:28,630
替代方法是，为了获得更高的性能，您必须付出代价
alternative to this is that in order to
get more performance you have to pay

271
00:24:28,630 --> 00:24:33,550
程序员重组您的软件以获得更好的性能
programmers to restructure your software
to get better performance to make it

272
00:24:33,550 --> 00:24:37,900
更有效率或应用某种专门技术更好的算法
more efficient or to apply some sort of
specialized techniques better algorithms

273
00:24:37,900 --> 00:24:42,940
或者如果您必须付钱给程序员来修复您的代码
or something if you have to pay
programmers to fix your code to be

274
00:24:42,940 --> 00:24:47,590
更快，这是一条昂贵的路要走，我们希望能够
faster that's an expensive way to go
we'd love to be able just oh by thousand

275
00:24:47,590 --> 00:24:51,610
计算机而不是十台计算机，吞吐量提高了一百倍
computers instead of ten computers and
get a hundred times more throughput

276
00:24:51,610 --> 00:24:56,830
这太棒了，因此这种可扩展性想法在
that's fantastic and so this sort of
scalability idea is a huge idea in the

277
00:24:56,830 --> 00:24:59,560
人们喜欢建立大型网站之类的东西时的后脑勺
backs of people's heads when they're
like building things like big websites

278
00:24:59,560 --> 00:25:04,510
如果继续运行，您是否知道要建立完整的计算机
that run on are you know building full
of computers if the building full of

279
00:25:04,510 --> 00:25:09,610
那里的计算机可以获得相应的性能，但是
computers is there to get a sort of
corresponding amount of performance but

280
00:25:09,610 --> 00:25:13,450
您必须谨慎设计才能真正得到
you have to be careful about the design
in order to actually get that

281
00:25:13,450 --> 00:25:21,910
性能如此常见，当我们查看图表或我正在
performance so often the way this looks
when we're looking at diagrams or I'm

282
00:25:21,910 --> 00:25:25,480
在本课程中编写图表是因为我不认为我们正在构建一个
writing diagrams in this course is that
I'm not supposing we're building a

283
00:25:25,480 --> 00:25:32,080
通常，您可能拥有一个您知道具有HTTP服务器的网站
website ordinarily you might have a
website that you know has a HTTP server

284
00:25:32,080 --> 00:25:36,390
假设它有某些类型的用户
let's say it has some types of users

285
00:25:36,900 --> 00:25:44,890
许多网络浏览器，并且它们与运行Python或PHP或其他功能的网络服务器通信
many web browsers and they talk to a web
server running Python or PHP or whatever

286
00:25:44,890 --> 00:25:52,740
某种Web服务器，并且Web服务器与某种数据库对话
sort of web server and the web server
talks to some kind of database

287
00:25:54,230 --> 00:25:58,620
你知道当你有一个或两个用户时，你可以只运行一台计算机
you know when you have one or two users
you can just have one computer running

288
00:25:58,620 --> 00:26:02,399
两者，也许是用于Web服务器的计算机，也可能是来自数据库的计算机
both and maybe a computer for the web
server and a computer from the database

289
00:26:02,399 --> 00:26:05,340
但也许突然之间，您会真正受到欢迎，并且您会起床并
but maybe all of a sudden you get really
proper popular and you'll be up and

290
00:26:05,340 --> 00:26:13,500
您是否知道1亿人注册了您的服务ID 
you've you know 100 million people sign
up your service ID how do you how do you

291
00:26:13,500 --> 00:26:17,899
一定可以解决您的问题，它可以在一台计算机上支持数百万人
fix your c-certainly can it support
millions of people on a single computer

292
00:26:17,899 --> 00:26:24,629
除非经过非常仔细的劳动密集型优化，但是您
except by extremely careful
labor-intensive optimization but you

293
00:26:24,629 --> 00:26:29,519
通常没有时间进行加速
don't have time for so typically the way
you're going to speed things up the

294
00:26:29,519 --> 00:26:33,539
您要做的第一件事是购买更多的Web服务器，然后拆分用户，以便
first thing you do is buy more web
servers and just split the user so that

295
00:26:33,539 --> 00:26:37,230
您知道用户访问网络服务器1的用户或用户的比例很少
you know how few users or some fraction
the user go to a web server 1 and the

296
00:26:37,230 --> 00:26:45,960
另一半您将它们发送到Web服务器2，因为也许您正在构建我
other half you send them to a web server
2 and because maybe you're building I

297
00:26:45,960 --> 00:26:49,440
不知道什么Reddit或所有用户都需要看到相同的东西
don't know what reddit or something
where all the users need to see the same

298
00:26:49,440 --> 00:26:54,029
数据最终，所有Web服务器都与后端通信，并且您可以
data ultimately you have all the web
servers talk to the backend and you can

299
00:26:54,029 --> 00:27:01,679
继续在这里添加Web服务器很长时间，因此这是一种
keep on adding web servers for a long
time here and so this is a way of

300
00:27:01,679 --> 00:27:04,259
如果您正在运行，则可以并行提高Web服务器代码的速度
getting parallel speed up on the web
server code you know if you're running

301
00:27:04,259 --> 00:27:09,570
 PHP或Python也许效率不高，只要每个单独的网站
PHP or Python maybe it's not too
efficient as long as each individual web

302
00:27:09,570 --> 00:27:12,840
服务器不会在数据库上增加太多负载，您可以添加很多网站
server doesn't put too much load on the
database you can add a lot of web

303
00:27:12,840 --> 00:27:20,669
服务器，然后再遇到问题，但是这种可伸缩性很少
servers before you run into problems but
this kind of scalability is rarely

304
00:27:20,669 --> 00:27:25,289
不幸的是，无限的肯定不是没有认真的思考等等。 
infinite unfortunately certainly not
without serious thought and so what

305
00:27:25,289 --> 00:27:29,309
这些系统往往会发生在您拥有10个或
tends to happen with these systems is
that at some point after you have 10 or

306
00:27:29,309 --> 00:27:33,450
现在突然有20或100个Web服务器都与同一个数据库通信
20 or 100 web servers all talking to the
same database now all of a sudden the

307
00:27:33,450 --> 00:27:37,049
数据库开始成为瓶颈，添加更多Web服务器不再有帮助
database starts to be a bottleneck and
adding more web servers no longer helps

308
00:27:37,049 --> 00:27:42,710
因此，您难得有全面的能力来分类无限数量的
so it's rare that you get full scale
ability to sort of infinite numbers of

309
00:27:42,710 --> 00:27:46,710
添加无限数量的计算机有时会耗尽您的电量，因为
adding infinite numbers of computers
some point you run out of gas because

310
00:27:46,710 --> 00:27:51,419
您添加更多计算机的位置不再是瓶颈
the place at which you are adding more
computers is no longer the bottleneck by

311
00:27:51,419 --> 00:27:54,269
拥有很多Web服务器，我们基本上消除了瓶颈
having lots and lots of web servers we
basically moved the bottleneck

312
00:27:54,269 --> 00:28:01,649
我认为这限制了从Web服务器到数据库的性能， 
I think it's limiting performance from
the web servers to the database and at

313
00:28:01,649 --> 00:28:05,730
这一点实际上您几乎肯定需要做一些设计工作，因为
this point actually you almost certainly
have to do a bit of design work because

314
00:28:05,730 --> 00:28:09,929
很少有您能采取任何直接方法
it's rare that you can
there's any straightforward way to take

315
00:28:09,929 --> 00:28:17,460
单个数据库并使用它来重构事物，或者您可以获取数据
a single database and sort of refactor
things with it or you can take data

316
00:28:17,460 --> 00:28:23,090
在单个数据库中排序并重构它，以便将其拆分为多个数据库
sorta in a single database and refactor
it so it's split over multiple databases

317
00:28:23,840 --> 00:28:29,309
但这通常是相当多的工作，而且因为它很笨拙，但是人们很多
but it's often a fair amount of work and
because it's awkward but people many

318
00:28:29,309 --> 00:28:33,389
人们实际上需要这样做，我们将在其中看到很多例子
people actually need to do this we're
gonna see a lot of examples in this

319
00:28:33,389 --> 00:28:37,529
人们谈论的分布式系统的课程是存储
course in which the distributed system
people are talking about is a storage

320
00:28:37,529 --> 00:28:42,659
系统，因为作者正在运行，所以您知道类似大型网站的信息
system because the authors were running
you know something like a big website

321
00:28:42,659 --> 00:28:49,429
无论如何，在单个数据库或存储服务器上用尽了所有电量，因此
that ran out of gas on a single database
or storage servers anyway so the

322
00:28:49,429 --> 00:28:56,330
可扩展性的故事是我们喜欢构建以这种方式扩展的系统，但您知道
scalability story is we love to build
systems that scale this way but you know

323
00:28:56,330 --> 00:29:01,950
很难实现或取消工作并进行设计工作以推动这一想法
it's hard to make it or takes work off
and design work to push this idea

324
00:29:01,950 --> 00:29:16,249
无限远，所以出现的另一个大话题是容错
infinitely far ok so another big topic
that comes up a lot is fault tolerance

325
00:29:22,249 --> 00:29:27,450
如果您要构建的系统中只有一台计算机，那么
if you're building a system with a
single computer in it well a single

326
00:29:27,450 --> 00:29:31,139
电脑经常可以工作很多年，就像我的办公室里有服务器那样
computer often can stay up for years
like I have servers in my office that

327
00:29:31,139 --> 00:29:35,909
已经运行了好几年没有崩溃，您知道计算机非常可靠
have been up for years without crashing
you know the computer is pretty reliable

328
00:29:35,909 --> 00:29:39,690
可靠的操作系统显然是我的建筑物的力量
the operating systems reliable
apparently the power in my building is

329
00:29:39,690 --> 00:29:43,139
非常可靠，因此拥有单台计算机并不少见，这只是一个
pretty reliable so it's not uncommon to
have single computers it's just a for

330
00:29:43,139 --> 00:29:48,149
但是，如果要从成千上万个系统中构建系统，那将是惊人的时间
amazing amount of time however if you're
building systems out of thousands of

331
00:29:48,149 --> 00:29:53,700
则即使每台计算机预计可以使用一年时间
computers then even if each computer can
be expected to stay up for a year with a

332
00:29:53,700 --> 00:29:57,119
千台计算机，这意味着您将拥有大约三台计算机
thousand computers that means you're
going to have like about three computer

333
00:29:57,119 --> 00:30:02,549
您的一千台计算机中每天的故障数量如此之多
failures per day in your set of a
thousand computers so solving big

334
00:30:02,549 --> 00:30:07,830
大型分布式系统的问题变成了非常罕见的容错能力
problems with big distributed systems
turns sort of very rare fault tolerance

335
00:30:07,830 --> 00:30:12,179
非常真实的故障非常罕见的故障问题转化为故障问题
very real failure very rare failure
problems into failure problems that

336
00:30:12,179 --> 00:30:15,809
在拥有一千台计算机的系统中几乎总是发生
happen just all the time in a system
with a thousand computers there's almost

337
00:30:15,809 --> 00:30:20,580
当然总是有东西坏了，总是有一些计算机或者
certainly always something broken it's
always some computer that's either

338
00:30:20,580 --> 00:30:24,840
崩溃或神秘，您知道运行不正确或缓慢或执行错误
crashed or mysteriously you know running
incorrectly or slowly or doing the wrong

339
00:30:24,840 --> 00:30:28,890
东西，也许有一部分网络，我们有一千台计算机
thing or maybe there's some piece of the
network with a thousand computers we got

340
00:30:28,890 --> 00:30:33,600
很多网络电缆和很多网络交换机，所以您知道
a lot of network cables and a lot of
network switches and so you know there's

341
00:30:33,600 --> 00:30:37,200
总是有人踩到的某些网络电缆不可靠，或者
always some network cable that somebody
stepped on and is unreliability or

342
00:30:37,200 --> 00:30:40,740
掉线的网络电缆或某些风扇损坏的网络，并且
network cable that fell out or some
networks which whose fan is broken and

343
00:30:40,740 --> 00:30:44,850
开关过热并发生故障，其中总是存在一些小问题
the switch overheated and failed there's
always some little problem somewhere in

344
00:30:44,850 --> 00:30:52,559
您的建筑物大小的分布式系统，如此之大，从根本上解决了问题
your building sized distributed system
so big scale turns problems from very

345
00:30:52,559 --> 00:30:56,549
罕见的事件，您不必真正担心那么多
rare events you really don't have to
worry about that much into just constant

346
00:30:56,549 --> 00:31:02,070
问题意味着失败必须是真实的，或者响应必须掩盖
problems that means the failure has to
be really or the response the masking of

347
00:31:02,070 --> 00:31:05,639
失败的能力而没有失败只是必须建立在
failures the ability to proceed without
failures just has to be built into the

348
00:31:05,639 --> 00:31:12,899
设计，因为总是有失败，而且您知道这是构建您的一部分
design because there's always failures
and you know it's part of building you

349
00:31:12,899 --> 00:31:16,620
为我们真正需要的应用程序程序员了解方便的抽象
know convenient abstractions for
application programmers we really need

350
00:31:16,620 --> 00:31:19,350
但要尽可能建立基础设施
that but to be able to build
infrastructure that as much as possible

351
00:31:19,350 --> 00:31:23,929
对应用程序程序员隐藏故障或掩盖故障之类的东西
hides the failures from application
programmers or masks them or something

352
00:31:23,929 --> 00:31:28,080
这样每个应用程序程序员都不必拥有完整的
so that every application programmer
doesn't have to have a complete

353
00:31:28,080 --> 00:31:35,100
对于可能发生的所有各种故障的复杂故事
complicated story for all the different
kinds of failures that can occur there's

354
00:31:35,100 --> 00:31:41,159
一堆关于错误的含义的不同概念
a bunch of different notions that you
can have about what it means to be fault

355
00:31:41,159 --> 00:31:46,679
容忍多一点，但你确切地知道我们的意思是， 
tolerant about a little more but you
know exactly what we mean by that we'll

356
00:31:46,679 --> 00:31:50,880
看到很多不同的口味，但在更常见的想法中， 
see a lot of a lot of different flavors
but among the more common ideas you see

357
00:31:50,880 --> 00:32:01,470
一个是可用性，所以您知道某些系统的设计使其在某些情况下
one is availability so you know some
systems are designed so that under some

358
00:32:01,470 --> 00:32:05,460
某种特定类型的故障并非所有故障，而是某些特定类型的故障
kind certain kinds of failures not all
failures but certain kinds of failures

359
00:32:05,460 --> 00:32:13,139
尽管出现故障，系统仍将继续运行，同时告知您
the system will keep operating despite
the failure while providing you know

360
00:32:13,139 --> 00:32:17,820
完好无损的服务，即使是
undamaged service the same kind of
service it would have provided even if

361
00:32:17,820 --> 00:32:21,289
没有失败，所以从某种意义上说，有些系统可用
there had been no failure so some
systems are available in that sense that

362
00:32:21,289 --> 00:32:25,950
你知道，所以如果你建立一个复制服务，也许有两个
up and up you know so if you build a
replicated service that maybe has two

363
00:32:25,950 --> 00:32:31,770
您知道其中一个副本副本服务器失败的副本可能失败
copies you know one of the replicas
replica servers fail fails maybe the

364
00:32:31,770 --> 00:32:37,050
其他服务器可以继续运行，但它们都失败了，当然不能
other server can continue operating
they both fail of course you can't you

365
00:32:37,050 --> 00:32:42,150
知道在这种情况下您无法保证可用性，因此可用系统通常
know you can't promise availability in
that case so available systems usually

366
00:32:42,150 --> 00:32:46,140
在某些失败情况下说得很好，我们将继续提供
say well under certain set of failures
we're going to continue providing

367
00:32:46,140 --> 00:32:50,790
服务，我们将可以使用的故障比发生的更多
service we're going to be available more
failures than that occur it won't be

368
00:32:50,790 --> 00:32:55,080
可以再使用另一种容错能力
available anymore
another kind of fault tolerance you

369
00:32:55,080 --> 00:32:59,130
可能除了可用性之外，或者除了可用性之外，还可能
might you might have or in addition to
availability or by itself as

370
00:32:59,130 --> 00:33:08,160
可恢复性，这意味着如果出现问题，可能
recoverability and what this means is
that if something goes wrong maybe the

371
00:33:08,160 --> 00:33:13,040
服务将停止工作，只是停止响应请求
service will stop working that it is
it'll simply stop responding to requests

372
00:33:13,040 --> 00:33:17,430
它会等待有人来修复或发生任何问题
and it will wait for someone to come
along and repair or whatever went wrong

373
00:33:17,430 --> 00:33:21,900
但是修复之后，系统将能够继续运行，好像什么也没有发生
but after the repair occurs the system
will be able to continue as if nothing

374
00:33:21,900 --> 00:33:25,590
不好的地方错了，所以这比
bad had gone wrong right so this is sort
of a weaker requirement than

375
00:33:25,590 --> 00:33:29,640
可用性，因为在此期间我们不会做任何事情
availability because here we're not
going to do anything while while the

376
00:33:29,640 --> 00:33:33,720
直到出现故障的组件被修复为止，否则我们
failed come until the failed component
has been repaired but the fact that we

377
00:33:33,720 --> 00:33:39,510
可以不知道就起床再去，但又不会失去正确性
can get up get going again without you
know but without any loss of correctness

378
00:33:39,510 --> 00:33:43,500
仍然是一个重要的要求，这意味着您知道可恢复的系统
is still a significant requirement it
means you know recoverable systems

379
00:33:43,500 --> 00:33:48,000
通常需要做一些事情，例如将最新日期保存在磁盘等上
typically need to do things like save
their latest date on disk or something

380
00:33:48,000 --> 00:33:51,090
当电源恢复后，他们可以在哪里找回它
where they can get it back
you know after the power comes back up

381
00:33:51,090 --> 00:33:57,870
甚至在可用系统之间，以使系统在实际中有用
and even among available systems in
order for a system to be useful in real

382
00:33:57,870 --> 00:34:04,290
生活通常是可用系统SPECT的方式是
life usually what the way available
systems are SPECT is that they're

383
00:34:04,290 --> 00:34:09,149
如果发生过多的故障，则直到出现一定数量的故障才可用
available until some number of failures
have happened if too many failures have

384
00:34:09,149 --> 00:34:14,820
发生可用系统将停止工作，或者您知道将停止响应
happened an available system will stop
working or you know will stop responding

385
00:34:14,820 --> 00:34:21,330
根本没有，但是只要修复了足够的东西，它就会继续运行，因此
at all but when enough things have been
repaired it'll continue operating so a

386
00:34:21,330 --> 00:34:25,139
良好的可用系统在某种程度上也可以恢复
good available system will sort of be
recoverable as well in a sensitive to

387
00:34:25,139 --> 00:34:28,469
发生许多失败，它将停止回答，但随后会
many failures occur
it'll stop answering but then will

388
00:34:28,469 --> 00:34:38,428
之后继续正确进行，所以这就是我们的爱-这就是我们想要的

389
00:34:38,429 --> 00:34:45,120
获得最大的锤子，我们将看到解决这些问题的多种方法
obtain the biggest hammer what we'll see
a number of approaches to solving these

390
00:34:45,120 --> 00:34:50,179
问题实际上是最重要的工具
problems there's really sort of
things that are the most important tools

391
00:34:50,179 --> 00:34:55,850
我们在这个部门中有一个是非易失性存储
we have in this department one is
non-volatile storage so that you know

392
00:34:55,850 --> 00:35:01,310
崩溃电源故障或建筑物范围内发生的任何电源故障
something crash power fails or whatever
there's a building wide power failure we

393
00:35:01,310 --> 00:35:05,330
可以使用非易失性存储，就像硬盘驱动器，闪存或固态存储
can use non-volatile store it's like
hard drives or flash or solid-state

394
00:35:05,330 --> 00:35:12,680
驱动器或某种用于存储检查点或状态日志的东西
drives or something to sort of store a
check point or a log of the state of a

395
00:35:12,680 --> 00:35:16,760
系统，然后在电源恢复供电或有人维修我们的电源时
system and then when the power comes
back up or somebody repairs our power

396
00:35:16,760 --> 00:35:20,510
供应商注意到我们将能够从硬盘读取最新状态
suppliers notice what we'll be able to
read our latest state off the hard drive

397
00:35:20,510 --> 00:35:29,390
并从那里继续，所以一种工具是非易失性存储， 
and continue from there so so one tool
is sort of non-volatile storage and the

398
00:35:29,390 --> 00:35:32,840
非易失性存储的管理Ning出现了很多，因为非易失性
management of non-volatile storage just
Ning comes up a lot because non-volatile

399
00:35:32,840 --> 00:35:37,460
存储往往更新成本很高，因此，大量的
storage tends to be expensive to update
and so a huge amount of the sort of

400
00:35:37,460 --> 00:35:42,470
构建高性能容错系统的本质
nitty-gritty of building sort of
high-performance fault-tolerant systems

401
00:35:42,470 --> 00:35:47,600
您知道可以避免写非易失性存储的聪明方法
is in you know clever ways to avoid
having to write the non-volatile storage

402
00:35:47,600 --> 00:35:53,000
在过去甚至今天都太多了，你知道写非易失性是什么
too much in the old days and even today
you know what writing non-volatile

403
00:35:53,000 --> 00:35:58,060
存储意味着要移动磁盘臂并等待磁盘旋转
storage meant was moving a disk arm and
waiting for a disk platter to rotate

404
00:35:58,060 --> 00:36:04,220
两者在您所知的范围内都非常缓慢
both of which are agonizingly slow on
the scale of you know three gigahertz

405
00:36:04,220 --> 00:36:08,990
微处理器的美好事物，例如闪存寿命要好很多，但仍然
microprocessors good things like flash
life is quite a bit better but still

406
00:36:08,990 --> 00:36:12,950
需要大量的思想才能获得良好的性能，而另一个则是
requires a lot of thought to get good
performance out of and the other big

407
00:36:12,950 --> 00:36:20,000
我们用于容错的工具是复制和管理
tool we have for fault tolerance is
replication and the management of

408
00:36:20,000 --> 00:36:26,510
复制副本有点棘手，您知道隐藏在其中的问题
replicated copies is sort of tricky you
know that sort of he problem lurking in

409
00:36:26,510 --> 00:36:30,800
任何复制的系统，其中我们有两个服务器，每个服务器假定都相同
any replicated system where we have two
servers each with a supposedly identical

410
00:36:30,800 --> 00:36:36,020
系统状态副本出现的关键问题始终是这两个
copy of the system state the key problem
that comes up is always that the two

411
00:36:36,020 --> 00:36:41,330
副本将意外地偏离同步状态，并且将不再是副本
replicas will accidentally drift out of
sync and will stop being replicas right

412
00:36:41,330 --> 00:36:45,410
这就是您所知道的每个设计背后的内容
and this is just you know with the back
of the every design that we're gonna see

413
00:36:45,410 --> 00:36:51,260
使用复制来获得容错能力和实验室-很多-都是
for using replication to get fault
tolerance and lab - a lot - you're all

414
00:36:51,260 --> 00:36:57,450
有关用于容错的复制副本的管理管理
about management management of
replicated copies for fault tolerance

415
00:36:57,450 --> 00:37:02,359
如您所见，它非常复杂
as you'll see it's pretty complex a

416
00:37:03,740 --> 00:37:17,549
最终主题最终交叉主题是一致性，因此这是我所举的例子
final topic final cross-cutting topic is
consistency so it's an example of what I

417
00:37:17,549 --> 00:37:22,079
假设我们正在构建分布式存储系统，这就是一致性
mean by consistency supposing we're
building a distributed storage system

418
00:37:22,079 --> 00:37:26,609
而且它是键/值服务，因此它仅支持两个操作，也许有一个
and it's a key/value service so it just
supports two operations maybe there's a

419
00:37:26,609 --> 00:37:33,089
进行操作，然后给它一个键和一个值，然后存储系统进行排序
put operation and you give it a key and
a value and that the storage system sort

420
00:37:33,089 --> 00:37:38,069
的藏匿值，因为此键的值保持它只是一个
of stashes away the value under as the
value for this key maintains it's just a

421
00:37:38,069 --> 00:37:43,920
很大的键和值表，然后客户端就可以很好地进行操作了
big table of keys and values and then
there's a good operation you the client

422
00:37:43,920 --> 00:37:49,530
向其发送密钥，并且应该知道存储服务，请使用
sends it a key and the storage service
is supposed to you know respond with the

423
00:37:49,530 --> 00:37:52,799
它已为该密钥权限存储的值的值，这很好
value of the value it has stored for
that key right and this is kind of good

424
00:37:52,799 --> 00:37:56,490
当我无法想到其他任何东西作为分布式系统的示例时
when I can't think of anything else as
an example of a distributed system all

425
00:37:56,490 --> 00:38:01,950
哦，没有键值服务，它们非常有用，就是
Oh without key value services and
they're very useful right they're just

426
00:38:01,950 --> 00:38:09,299
当然是一种基本的简单版本的存储系统
sort of a kind of fundamental simple
version of a storage system so of course

427
00:38:09,299 --> 00:38:15,150
如果您是应用程序程序员，那么这两种操作对您很有帮助
if you're an application programmer it's
helpful if these two operations kind of

428
00:38:15,150 --> 00:38:18,630
具有相关的含义，您可以阅读手册和手册
have meanings attached to them that you
can go look in the manual and the manual

429
00:38:18,630 --> 00:38:23,520
说你知道这是什么意思如果电话打对了你会得到什么
says you know what it what it means what
you'll get back if you call get right

430
00:38:23,520 --> 00:38:28,109
一切对您而言意味着什么，请立即放好，以便立即
and sort of what it means for you to
call put all right so it's immediate so

431
00:38:28,109 --> 00:38:31,440
某种规格说明他们的意思，例如谁知道你怎么能
some sort of spec for what they meant
otherwise like who knows how can you

432
00:38:31,440 --> 00:38:35,250
可能在编写应用程序时未说明put get是什么
possibly write an application without a
description of what putting get are

433
00:38:35,250 --> 00:38:40,200
应该要做的，这是一致性的主题，也是为什么
supposed to do and this is the topic of
consistency and the reason why it's

434
00:38:40,200 --> 00:38:46,200
分布式系统中有趣的是，无论是性能还是故障
interesting in distributed systems is
that both for performance and for fault

435
00:38:46,200 --> 00:38:50,400
容忍的原因容错的原因我们经常有多个副本
tolerant reasons fault tolerance reason
we often have more than one copy of the

436
00:38:50,400 --> 00:38:55,500
数据随处可见，因此您可以在非分布式系统中
data floating around so you know in a
non distributed system where you just

437
00:38:55,500 --> 00:39:02,579
有一个带有单个表的服务器，虽然不是总是，但是
have a single server with a single table
there's often although not always but

438
00:39:02,579 --> 00:39:05,940
人们对布丁的接受程度通常相对没有歧义
there's often like relatively no
ambiguity about what pudding get could

439
00:39:05,940 --> 00:39:08,980
可能意味着对李先生的权利，你知道认罪的意思是
possibly mean right in
to ative Lee you know what put means is

440
00:39:08,980 --> 00:39:12,550
更新表，获取的意思就是获取存储在其中的版本
update the table and what get means is
just get me the version that's stored in

441
00:39:12,550 --> 00:39:18,640
该表，但是在分布式系统中存在多个副本
the table which but in a distributed
system where there's more than one copy

442
00:39:18,640 --> 00:39:23,890
由于复制或缓存或谁知道可能会有什么原因
in the data due to replication or
caching or who knows what there may be

443
00:39:23,890 --> 00:39:32,380
此键值对有很多不同的版本，就像一个
lots of different versions of this key
value pair floating around like if one

444
00:39:32,380 --> 00:39:36,910
如果假设某些客户端发行了一份副本，您知道该副本的数量，并且您知道
of the replicas you know if supposing
some client issues a put and you know

445
00:39:36,910 --> 00:39:48,070
服务器有两个副本，所以它们都有正确的键值表
there's two copies of the the server so
they both have a key value table right

446
00:39:48,070 --> 00:39:55,360
也许关键之一对他们两个都有价值20，然后一些客户问题
and maybe key one has value twenty on
both of them and then some client issues

447
00:39:55,360 --> 00:40:00,310
一个不错的看跌期权，我们在这里有客户，它将发送一个要更新的看跌期权
a put nice we have client over here and
it's gonna send a put it wants to update

448
00:40:00,310 --> 00:40:04,960
一个21的值好吧，也许这是在计算东西
the value of one to be twenty-one all
right maybe it's counting stuff in this

449
00:40:04,960 --> 00:40:13,750
密钥值服务器发送带有密钥一和值二十一的看跌期权，将其发送到
key value server so sends a put with key
one and value twenty one it sends it to

450
00:40:13,750 --> 00:40:18,010
第一台服务器，它将发送您知道要更新的同一个put 
the first server and it's about to send
the same put you know wants to update

451
00:40:18,010 --> 00:40:22,300
两个副本都正确，这会使它们保持同步，这将要发送此认沽权，但是
both copies right it keeps them in sync
it's about to send this put but just

452
00:40:22,300 --> 00:40:26,950
在将其发送到第二台服务器之前，我崩溃了或掉电了
before it sends to put to the second
server crashes I power failure or bug an

453
00:40:26,950 --> 00:40:30,640
操作系统之类的东西，所以现在可悲的是，我们发送了
operating system or something so now the
state were left in sadly is that we sent

454
00:40:30,640 --> 00:40:37,300
这个看跌期权，所以我们更新了两个副本之一，没有价值二十
this put and so we've updated one of the
two replicas didn't have value twenty

455
00:40:37,300 --> 00:40:40,870
一个，但另一个仍然有二十个，现在有人来读
one but the other ones still with twenty
now somebody comes along and reads with

456
00:40:40,870 --> 00:40:45,070
得到，他们可能得到他们想要读取与键一相关联的值
a get and they might get they want to
read the value associated with key one

457
00:40:45,070 --> 00:40:48,100
他们可能会得到二十一，或者他们可能会得到二十，这取决于他们与谁交谈
they might get twenty one or they might
get twenty depending on who they talk to

458
00:40:48,100 --> 00:40:52,600
即使是规则，如果您总是
and even if the rule is you always talk
to the top server first if you're

459
00:40:52,600 --> 00:40:56,020
建立容错系统实际规则必须是
building a fault-tolerant system the
actual rule has to be oh you talk to the

460
00:40:56,020 --> 00:41:00,810
除非失败，否则首先是顶级服务器
top server first unless it's failed in
which case you talk to the bottom server

461
00:41:00,810 --> 00:41:06,610
因此，无论哪种方式，总有一天您可能会冒险将这种陈旧的数据副本暴露给某些
so either way someday you risk exposing
this stale copy of the data to some

462
00:41:06,610 --> 00:41:10,630
未来再次可能是许多人得到了更新的二十一，然后像
future again it could be that many gets
get the updated twenty one and then like

463
00:41:10,630 --> 00:41:14,920
下周突然有些收益，你知道一个星期的副本
next week all of a sudden some get
yields you know a week old copy of the

464
00:41:14,920 --> 00:41:23,720
数据，所以不是很一致，所以顺序，但是您知道
data so that's not very consistent
right so in order but you know it's the

465
00:41:23,720 --> 00:41:29,210
可能会发生的事情我们不小心，所以您知道我们需要
kind of thing that could happen right
we're not careful so you know we need to

466
00:41:29,210 --> 00:41:33,920
我们是否需要实际写下有关看跌期权的规则， 
have we need to actually write down what
the rules are going to be about puts and

467
00:41:33,920 --> 00:41:39,230
由于复制而受到这种危险，事实证明
gets given this danger of due to
replication and it turns out there's

468
00:41:39,230 --> 00:41:47,030
您可以拥有许多不同的一致性定义，您知道其中许多是
many different definitions you can have
of consistency you know many of them are

469
00:41:47,030 --> 00:41:52,940
相对简单，其中许多听起来像是我得到了你
relatively straightforward many of them
sound like well I get yields the you

470
00:41:52,940 --> 00:42:00,170
知道最近完成的看跌期权的看跌期权价值，所以
know value put by the most recently
completed put all right so that's

471
00:42:00,170 --> 00:42:05,390
通常被称为强一致性，事实证明，构建它也非常有用
usually called strong consistency it
turns out also it's very useful to build

472
00:42:05,390 --> 00:42:08,660
例如，那里的一致性较弱的系统不会
systems that have much weaker
consistency there for example do not

473
00:42:08,660 --> 00:42:15,170
保证像get这样的东西都能看到最新put和
guarantee anything like a get sees the
value written by the most recent put and

474
00:42:15,170 --> 00:42:23,030
原因是他们通常拥有非常一致的系统
the reason so there's there strongly
consistent systems they usually have

475
00:42:23,030 --> 00:42:27,290
一些版本可以看到最新的看跌期权，尽管您必须做很多
some version that gets seen most recent
puts although you have to there's a lot

476
00:42:27,290 --> 00:42:32,180
要解决的细节还有每周一致的多种口味
of details to work out there's also
weekly consistent many sort of flavors

477
00:42:32,180 --> 00:42:36,650
每周不进行任何此类保证的系统
of weekly consistent systems that do not
make any such guarantee that you know

478
00:42:36,650 --> 00:42:41,690
可以保证你知道如果有人进行认沽，那么你可能看不到
may guarantee well you're you know if
someone does a put then you may not see

479
00:42:41,690 --> 00:42:45,740
看跌期权，您可能会看到看跌期权未更新的旧值
the put you may see old values that
weren't updated by the put for an

480
00:42:45,740 --> 00:42:51,290
无限的时间，也许是人们非常感兴趣的原因
unbounded amount of time maybe and the
reason for people being very interested

481
00:42:51,290 --> 00:42:57,020
在小麦一致性方案中，具有Rezac的强一致性
in wheat consistency schemes is that
strong consistency that is having Rezac

482
00:42:57,020 --> 00:43:02,690
蔡承租人一定会看到最新的权利
Chua lessee be guaranteed to see the
most recent right that's a very

483
00:43:02,690 --> 00:43:08,810
实施昂贵的规范，因为这意味着您几乎可以肯定
expensive spec to implement because what
it means is almost certainly that you

484
00:43:08,810 --> 00:43:12,470
必须有人必须做很多沟通才能真正
have to somebody has to do a lot of
communication in order to actually

485
00:43:12,470 --> 00:43:16,450
如果有多个副本，请实施一些具有高度一致性的概念
implement some notion of strong
consistency if you have multiple copies

486
00:43:16,450 --> 00:43:22,490
这意味着作者或读者，或者也许两者都要咨询
it means that either the writer or the
reader or maybe both has to consult

487
00:43:22,490 --> 00:43:28,340
在这种情况下，每一个副本都可能导致客户端崩溃， 
every copy like in this case where you
know maybe a client crash left one

488
00:43:28,340 --> 00:43:31,820
已更新，但如果要实施强大的功能，则不会更新其他内容
updated but not the other if we wanted
to implement strong

489
00:43:31,820 --> 00:43:35,210
西塞顿（Sisseton）在他们看来，在这个系统中，我们可能会让读者阅读
Sisseton see in them maybe a simple way
in this system we'd have readers read

490
00:43:35,210 --> 00:43:39,560
两份副本，或者如果有多个副本，则所有副本均使用
both of the copies or if there's more
than one copy all the copies and use the

491
00:43:39,560 --> 00:43:44,870
他们发现的最新书面价值，但价格昂贵，很多
most recently written value that they
find but that's expensive that's a lot

492
00:43:44,870 --> 00:43:51,620
之所以要读取一个值，是为了避免尽可能多地交流
of chitchat to read one value so in
order to avoid communication as much as

493
00:43:51,620 --> 00:43:56,810
可能尤其如此，如果复制品距离很远，人们会建立薄弱的系统， 
possible particularly if replicas are
far away people build weak systems that

494
00:43:56,810 --> 00:44:02,840
在这种情况下，实际上可能允许过时地读取旧值，尽管
might actually allow the stale read of
an old value in this case although

495
00:44:02,840 --> 00:44:06,980
通常会有更多的语义关联到这些较弱的方案中
there's often more semantics attached to
that to try to make these weak schemes

496
00:44:06,980 --> 00:44:13,420
更有用，我们是您知道强大的一致性的沟通问题
more useful and we're this communication
problem you know strong consistency

497
00:44:13,420 --> 00:44:19,370
需要昂贵的沟通，这确实使您陷入麻烦
requiring expensive communication where
this really runs you into trouble is

498
00:44:19,370 --> 00:44:24,530
如果我们将复制用于容错，那么我们真的想要
that if we're using replication for
fault tolerance then we really want the

499
00:44:24,530 --> 00:44:29,210
具有独立故障概率的副本具有不相关的故障
replicas to have independent failure
probability to have uncorrelated failure

500
00:44:29,210 --> 00:44:34,850
因此，例如，将我们的数据的两个副本都放在相同的伊拉克
so for example putting both of the
replicas of our data in the same iraq in

501
00:44:34,850 --> 00:44:38,360
在同一个机房​​中，这可能是一个非常糟糕的主意
the same machine room it's probably a
really bad idea

502
00:44:38,360 --> 00:44:42,410
因为如果有人通过电源线绊到那个机架，我们的两个副本
because if someone trips over the power
cable to that rack both of our copies of

503
00:44:42,410 --> 00:44:46,190
我们的数据将消失，因为它们都连接到相同的电源
our data are going to die because
they're both attached to the same power

504
00:44:46,190 --> 00:44:53,240
在同一机架中连接电缆，因此在搜索中将副本作为独立的
cable in the same rack so in the search
for making replicas as independent and

505
00:44:53,240 --> 00:44:57,860
为了获得体面的容错能力，人们可能会喜欢失败
failure as possible in order to get
decent fault tolerance people would love

506
00:44:57,860 --> 00:45:02,960
将不同的副本尽可能地分开，例如在不同的城市或
to put different replicas as far apart
as possible like in different cities or

507
00:45:02,960 --> 00:45:07,100
也许在大陆的相对两侧，所以一场地震摧毁了一个数据
maybe on opposite sides of the continent
so an earthquake that destroys one data

508
00:45:07,100 --> 00:45:11,840
中心极不可能破坏其他数据中心
center will be extremely unlikely to
also destroy the other data center that

509
00:45:11,840 --> 00:45:17,420
作为您知道的另一个副本，因此我们很乐意能够做到这一点
as the other copy you know so we'd love
to be able to do that if you do that

510
00:45:17,420 --> 00:45:23,660
然后另一个副本在数千英里之外
then the other copy is thousands of
miles away and the rate at which light

511
00:45:23,660 --> 00:45:28,550
行驶意味着可能需要数毫秒或数十倍的时间
travels means that it may take on the
order of milliseconds or tens of

512
00:45:28,550 --> 00:45:33,380
毫秒以与整个非洲的数据中心进行通信，以便
milliseconds to communicate to a data
center across the continent in order to

513
00:45:33,380 --> 00:45:38,450
更新数据的另一个副本，以便进行通信
update the other copy of the data and so
that makes this the communication

514
00:45:38,450 --> 00:45:42,350
强一致性所需的，可能极度良好的一致性
required for strong consistency for good
consistency potentially extremely

515
00:45:42,350 --> 00:45:45,319
就像每次您想做其中一件歌剧一样昂贵
expensive like every time you want to do
one of these put opera

516
00:45:45,319 --> 00:45:49,099
或再次取决于您的实施方式，您可能必须坐在那里
or maybe again depending on how you
implement it you might have to sit there

517
00:45:49,099 --> 00:45:52,940
等待大约10或20或30毫秒才能与对方通话
waiting for like 10 or 20 or 30
milliseconds in order to talk to both

518
00:45:52,940 --> 00:45:56,749
数据副本，以确保它们都已更新或已检查
copies of the data to ensure that
they're both updated or or both checked

519
00:45:56,749 --> 00:46:04,039
要找到最新的副本，那笔巨额费用是10或
to find the latest copy and that
tremendous expense right this is 10 or

520
00:46:04,039 --> 00:46:07,789
在20或30毫秒的机器上，毕竟我将执行十亿
20 or 30 milliseconds on machines that
after all I'll execute like a billion

521
00:46:07,789 --> 00:46:11,539
每秒的指令数，因此我们在浪费大量潜在指令的同时
instructions per second so we're wasting
a lot of potential instructions while we

522
00:46:11,539 --> 00:46:16,009
等待人们经常使用弱得多的系统，您只能更新
wait people often go much weaker systems
you're allowed to only update the

523
00:46:16,009 --> 00:46:20,089
最近的副本，您只查询了最近的副本，我的意思是说有很大的一种
nearest copy you're only consulted
nearest copy I mean there's a huge sort

524
00:46:20,089 --> 00:46:26,839
如何构造弱点的学术研究和现实世界研究
of amount of academic and real-world
research on how to structure weak

525
00:46:26,839 --> 00:46:30,380
一致性保证，因此它们实际上对应用程序以及
consistency guarantees so they're
actually useful to applications and how

526
00:46:30,380 --> 00:46:36,349
充分利用它们，以便获得高性能
to take advantage of them in order to
actually get high performance alright so

527
00:46:36,349 --> 00:46:43,729
这是该课程中技术思想的闪电预览
that's a lightning preview of the
technical ideas in the course any

528
00:46:43,729 --> 00:46:50,869
在我开始谈论MapReduce之前，我对此有疑问
questions about this before I start
talking about MapReduce all right I want

529
00:46:50,869 --> 00:46:55,519
切换到Map Reduce实际上是一种详细的案例研究
to switch to Map Reduce that's a sort of
detailed case study that's actually

530
00:46:55,519 --> 00:47:02,420
将说明我们现在在这里谈论的大多数想法
going to illustrate most of the ideas
that we've been talking about here now

531
00:47:02,420 --> 00:47:11,989
产生最初由Google I设计和制造并使用的系统
produces a system that was originally
designed and built and used by Google I

532
00:47:11,989 --> 00:47:17,269
认为该论文可以追溯到2004年，他们面临的问题是
think the paper dates back to 2004 the
problem they were faced with was that

533
00:47:17,269 --> 00:47:22,759
他们在TB和TB的数据上运行大量计算，例如
they were running huge computations on
terabytes and terabytes of data like

534
00:47:22,759 --> 00:47:29,660
创建网络所有内容的索引或分析链接
creating an index of all of the content
of the web or analyzing the link

535
00:47:29,660 --> 00:47:35,029
整个网络的结构以便识别最重要的页面或
structure of the entire web in order to
identify the most important pages or the

536
00:47:35,029 --> 00:47:39,140
您所知道的最权威的页面整个网络在当时都是如此
most authoritative pages as you know the
whole web is what's even in those days

537
00:47:39,140 --> 00:47:47,029
 Web的数十兆字节的数据构建索引基本上相当于一个
tens of terabytes of data building index
of the web is basically equivalent to a

538
00:47:47,029 --> 00:47:52,069
您可以合理地对整个数据进行排序
sort running sort of the entire data
sort you know ones like reasonably

539
00:47:52,069 --> 00:47:56,630
昂贵，并且按照我一直以来的方式对整个内容进行排序
expensive and to run a sort on the
entire content to the way I've been a

540
00:47:56,630 --> 00:47:59,990
单台计算机要花多长时间，但您知道
single computer
how long would have taken but you know

541
00:47:59,990 --> 00:48:04,309
是数周，数月或数年之类的时间，所以Google当时是
it's weeks or months or years or
something so Google the time was

542
00:48:04,309 --> 00:48:08,539
迫切希望能够对成千上万的海量数据进行海量计算
desperate to be able to run giant
computations on giant data on thousands

543
00:48:08,539 --> 00:48:12,980
的计算机，以便计算可以快速完成它是
of computers in order that the
computations could finish rapidly it's

544
00:48:12,980 --> 00:48:16,400
值得他们购买大量计算机，以便他们的工程师
worth it to them to buy lots of
computers so that their engineers

545
00:48:16,400 --> 00:48:19,519
无需花费大量时间阅读报纸或其他内容
wouldn't have to spend a lot of time
reading the newspaper or something

546
00:48:19,519 --> 00:48:27,410
等待他们的大型计算机工作完成，因此有一段时间
waiting for their big compute jobs to
finish and so for a while they had their

547
00:48:27,410 --> 00:48:30,619
聪明的工程师或手写体，您知道是否需要编写网络
clever engineer or sort of handwrite you
know if you needed to write a web

548
00:48:30,619 --> 00:48:35,809
索引器或某种类型的林肯会花费您知道的Google眨眼分析工具
indexer or some sort of Lincoln outlay a
blink analysis tool you know Google

549
00:48:35,809 --> 00:48:38,599
买了电脑，他们说在这里你知道的工程师会写，但是从不
bought the computers and they say here
engineers you know do write but never

550
00:48:38,599 --> 00:48:41,269
您在这些计算机上喜欢的任何软件，您都知道他们会
whatever software you like on these
computers and you know they would

551
00:48:41,269 --> 00:48:46,279
费力地编写一种一次性的手动咬软件
laborious ly write the sort of one-off
manually bitten software to take

552
00:48:46,279 --> 00:48:49,609
他们正在解决的任何问题，以某种方式将其大量耕种
whatever problem they were working on
and so to somehow farm it out to a lot

553
00:48:49,609 --> 00:48:56,809
的计算机，并组织该计算并取回数据（如果您
of computers and organize that
computation and get the data back if you

554
00:48:56,809 --> 00:49:01,789
只雇用熟练的分布式系统专家的工程师，也许那是
only hire engineers who are skilled
distributed systems experts maybe that's

555
00:49:01,789 --> 00:49:07,490
好的，尽管即使那样可能还是很浪费工程工作，但是他们
ok although even then it's probably very
wasteful of engineering effort but they

556
00:49:07,490 --> 00:49:15,009
想要雇用在其他方面很有技巧的人
wanted to hire people who were skilled
at something else and not necessarily

557
00:49:15,160 --> 00:49:18,559
想花所有时间编写分布式系统软件的工程师
engineers who wanted to spend all their
time writing distributed system software

558
00:49:18,559 --> 00:49:22,309
所以他们确实需要某种框架，以使其易于
so they really needed some kind of
framework that would make it easy to

559
00:49:22,309 --> 00:49:28,130
只是让他们的工程师写下他们想要的任何分析的胆量
just have their engineers write the kind
of guts of whatever analysis they wanted

560
00:49:28,130 --> 00:49:32,990
就像排序算法或Web索引或链接分析器一样
to do like the sort algorithm or a web
index or link analyzer or whatever just

561
00:49:32,990 --> 00:49:36,740
编写该应用程序的胆量而无法在数千个应用程序上运行
write the guts of that application and
not be able to run it on a thousands of

562
00:49:36,740 --> 00:49:41,539
电脑而不必担心如何分散工作的细节
computers without worrying about the
details of how to spread the work over

563
00:49:41,539 --> 00:49:45,950
数以千计的计算机如何组织数据移动
the thousands of computers how to
organize whatever data movement was

564
00:49:45,950 --> 00:49:50,630
需要如何应对不可避免的失败，所以他们正在寻找
required how to cope with the inevitable
failures so they were looking for a

565
00:49:50,630 --> 00:49:54,740
框架，使非专业人员可以轻松编写和
framework that would make it easy for
non specialists to be able to write and

566
00:49:54,740 --> 00:50:03,609
运行大型分布式计算，这就是MapReduce的全部意义
run giant distributed computations and
so that's what MapReduce is all about

567
00:50:03,609 --> 00:50:09,930
想法是程序员只是编写应用程序设计器
and the idea is that the programmer just
write the application designer

568
00:50:09,930 --> 00:50:14,369
这种分布式计算的使用者，我只能够编写一个简单的Map
consumer of this distributed computation
I'm just be able to write a simple map

569
00:50:14,369 --> 00:50:18,240
什么都不知道的函数和简单的reduce函数
function and a simple reduce function
that don't know anything about

570
00:50:18,240 --> 00:50:25,079
发行版和MapReduce框架将负责其他所有事项，因此
distribution and the MapReduce framework
would take care of everything else so an

571
00:50:25,079 --> 00:50:30,900
假设MapReduce所做的工作的抽象视图是通过假设
abstract view of how what MapReduce is
up to is it starts by assuming that

572
00:50:30,900 --> 00:50:35,430
有一些输入，输入被分成几整堆
there's some input and the input is
split up into some a whole bunch of

573
00:50:35,430 --> 00:50:43,109
不同的文件或数据块，以某种方式，所以我们在想，不，是的，您知道
different files or chunks in some way so
we're imagining that no yeah you know

574
00:50:43,109 --> 00:50:54,240
输入文件一，放置文件二，以此类推，您知道这些输入也许是您知道的网络
input file one and put file two etc you
know these inputs are maybe you know web

575
00:50:54,240 --> 00:50:58,020
从网络爬网的页面或更可能包含的大文件
pages crawled from the web or more
likely sort of big files that contain

576
00:50:58,020 --> 00:51:03,420
许多网站，每个网站都包含许多从网络抓取的网络文件， 
many web each of which contains many web
files crawl from the web all right and

577
00:51:03,420 --> 00:51:07,950
 Map Reduce的开始方式是您要查找Map
the way Map Reduce
starts is that you're to find a map

578
00:51:07,950 --> 00:51:15,890
函数，MapReduce框架将在每个
function and the MapReduce framework is
gonna run your map function on each of

579
00:51:15,890 --> 00:51:23,190
输入文件，当然您可以在这里看到一些明显的
the input files and of course you can
see here there's some obvious

580
00:51:23,190 --> 00:51:28,349
可用的并行性可以并行运行这些映射，因此每个映射
parallelism available can run the maps
in parallel so the each of these map

581
00:51:28,349 --> 00:51:32,400
函数仅看起来像此输入，并产生输出，该输出为Map
functions only looks as this input and
produces output the output that a map

582
00:51:32,400 --> 00:51:36,750
需要产生的功能是一个列表，您知道它需要一个文件作为输入
function is required to produce is a
list you know it takes a file as input

583
00:51:36,750 --> 00:51:42,180
文件是输入数据的一部分，它会生成一个密钥列表
and the file is some fraction of the
input data and it produces a list of key

584
00:51:42,180 --> 00:51:48,510
值对作为map函数的输出，例如，让我们假设
value pairs as output the map function
and so for example let's suppose we're

585
00:51:48,510 --> 00:51:56,400
编写最简单的MapReduce示例单词计数MapReduce工作目标
writing the simplest possible MapReduce
example a word count MapReduce job goal

586
00:51:56,400 --> 00:52:00,390
是计算每个单词出现的次数，因此您的Map功能可能
is to count the number of occurrences of
each word so your map function might

587
00:52:00,390 --> 00:52:06,930
发出键值对，其中键是单词，值只是一个，所以
emit key value pairs where the key is
the word and the value is just one so

588
00:52:06,930 --> 00:52:10,410
对于C处的每个单词，则此映射函数会将输入拆分为
for every word at C so then this map
function will split the input up into

589
00:52:10,410 --> 00:52:14,309
单词或其他地方，它发出该单词作为键，并发出1作为
words or everywhere ditzies
it emits that word as the key and 1 as

590
00:52:14,309 --> 00:52:18,359
该值，然后再将所有这些值累加，以获得
the value and then later on will count
up all those ones in order to get the

591
00:52:18,359 --> 00:52:23,229
最终输出，所以您知道输入1包含单词
final output so you know maybe input 1
has the word

592
00:52:23,229 --> 00:52:28,569
里面有a，里面有单词B，因此Map要生​​成的输出是
a in it and the word B in it and so the
output the map is going to produce is

593
00:52:28,569 --> 00:52:35,650
密钥A值一个密钥B值一个可能第二个不能通信看到文件
key a value one key B value one maybe
the second not communication sees a file

594
00:52:35,650 --> 00:52:43,119
它里面有一个B，别无其他，所以它将实现输出b1 
that has a B in it and nothing else so
it's going to implement output b1 maybe

595
00:52:43,119 --> 00:52:50,140
第三个输入中有一个A和一个C，所以我们运行所有这些映射
this third input has an A in it and a C
in it alright so we run all these maps

596
00:52:50,140 --> 00:52:55,059
在所有输入文件上，我们通过纸质电话获得此中间件
on all the input files and we get this
intermediate with the paper calls

597
00:52:55,059 --> 00:53:00,420
中间输出，对于每个映射都是一组键值对作为输出
intermediate output which is for every
map a set of key value pairs as output

598
00:53:00,420 --> 00:53:07,059
然后计算的第二阶段是运行约简，想法是
then the second stage of the computation
is to run the reduces and the idea is

599
00:53:07,059 --> 00:53:12,609
 MapReduce框架从的所有Map中收集所有实例
that the MapReduce framework collects
together all instances from all maps of

600
00:53:12,609 --> 00:53:16,869
每个关键字，以便MapReduce框架将所有
each key word so the MapReduce framework
is going to collect together all of the

601
00:53:16,869 --> 00:53:22,599
您会从每张Map中知道每个键值对为a的键值对
A's you know from every map every key
value pair whose key was a it's gonna

602
00:53:22,599 --> 00:53:28,289
收集全部并交给他们
take collect them all and hand them to

603
00:53:30,390 --> 00:53:35,529
程序员一个电话来寻找归约函数，然后
one call of the programmer to find
reduce function and then it's gonna take

604
00:53:35,529 --> 00:53:39,699
所有的B并收集在一起，当然，您知道需要一个真正的
all the B's and collect them together of
course you know requires a real

605
00:53:39,699 --> 00:53:44,019
收集，因为它们是密钥B的不同实例，由
collection because they were different
instances of key B were produced by

606
00:53:44,019 --> 00:53:48,609
在不同的计算机上显示Map的不同指示，所以我们不在谈论
different indications of map on
different computers so we're not talking

607
00:53:48,609 --> 00:53:53,339
关于数据移动的信息，所以我们要收集所有B键并将其交给
about data movement I'm so we're gonna
collect all the B keys and hand them to

608
00:53:53,339 --> 00:54:01,959
不同的reduce调用具有所有B键作为其参数，并且相同
a different call to reduce that has all
of the B keys as its arguments and same

609
00:54:01,959 --> 00:54:09,160
作为C，因此MapReduce框架将安排一个
as C so there's going to be the
MapReduce framework will arrange for one

610
00:54:09,160 --> 00:54:17,140
调用以减少出现在任何数学输出中的每个键，并且
call to reduce for every key that
occurred in any of the math output and

611
00:54:17,140 --> 00:54:23,499
您知道我们这类愚蠢的字数示例
you know for our sort of silly word
count example all these reduces have to

612
00:54:23,499 --> 00:54:28,329
做或其中任何一个要做的只是计算传递给它的项目数
do or any one of them has to do is just
count the number of items passed to it

613
00:54:28,329 --> 00:54:31,059
甚至不必查看这些项目，因为它知道每个项目都是
doesn't even have to look at the items
because it knows that each of them is

614
00:54:31,059 --> 00:54:35,769
这个词是负责加一是你不必看的价值
the word is responsible for plus one is
the value you don't have to look at

615
00:54:35,769 --> 00:54:41,590
我们只计算的那些，因此减少将产生一个和
those ones we've just count
so this reduce is going to produce a and

616
00:54:41,590 --> 00:54:47,680
然后减少其输入的数量，它将产生关联的密钥
then the count of its inputs this reduce
it's going to produce the key associated

617
00:54:47,680 --> 00:54:57,040
与它，然后计数它的值也是两个，所以这是一个
with it and then count of its values
which is also two so this is what a

618
00:54:57,040 --> 00:55:07,200
典型的MapReduce作业看起来很高级，只是为了完整性
typical MapReduce job looks like the
high level just for completeness the

619
00:55:07,200 --> 00:55:12,480
好一点的术语，整个计算称为工作
well some a little bit of terminology
the whole computation is called the job

620
00:55:12,480 --> 00:55:19,000
 MapReduce的任何调用都称为任务，因此我们拥有整个工作，并且
anyone invocation of MapReduce is called
a task so we have the entire job and

621
00:55:19,000 --> 00:55:27,220
它由一堆数学任务然后再由一堆产生的任务组成
it's made up of a bunch of math tasks
and then a bunch of produced tasks so

622
00:55:27,220 --> 00:55:31,150
这是这个字数的一个例子，您知道什么是Map并减少
it's an example for this word count you
know the what the map and reduce

623
00:55:31,150 --> 00:55:45,130
函数看起来像map函数将值作为键
functions would look like the map
function takes a key in the value as

624
00:55:45,130 --> 00:55:48,070
参数，现在我们正在谈论像用普通语言编写的函数
arguments and now we're talking about
functions like written in an ordinary

625
00:55:48,070 --> 00:55:54,820
诸如C ++或Java之类的编程语言，或者谁知道呢，所以这仅仅是代码
programming language like C++ or Java or
who knows what so this is just code

626
00:55:54,820 --> 00:55:58,870
普通人可以写一个用于字数统计的map函数的功能是
people ordinary people can write what a
map function for word count would do is

627
00:55:58,870 --> 00:56:05,110
拆分键是通常被忽略的文件名，我们真的很在乎
split the the key is the file name which
typically is ignored we really care what

628
00:56:05,110 --> 00:56:12,250
文件名是，而V是此Map输入文件的内容，因此V为
the file name was and the V is the
content of this maps input file so V is

629
00:56:12,250 --> 00:56:21,760
你知道只是包含所有这些文本，我们将V分解为单词，然后
you know just contains all this text
we're gonna split V into words and then

630
00:56:21,760 --> 00:56:24,630
每个字
for each word

631
00:56:30,890 --> 00:56:36,890
我们只是要发出和发出需要两个参数的手套，您知道冷静地可以
we're just gonna emit and emit takes two
arguments mitts you know calmly map can

632
00:56:36,890 --> 00:56:41,299
生成发射由MapReduce框架提供，我们通过手工生成来生成
make emit is provided by the MapReduce
framework we get to produce we hand emit

633
00:56:41,299 --> 00:56:49,730
一个是单词的键，一个是字符串one的值，就是这样
a key which is the word and a value
which is the string one so that's it for

634
00:56:49,730 --> 00:56:54,859
 map函数和单词计数map函数以及MapReduce的字面意思是
the map function and a word count map
function and MapReduce literally it

635
00:56:54,859 --> 00:57:00,309
可能就这么简单，所以就有了使
could be this simple
so there's sort of promise to make the

636
00:57:00,309 --> 00:57:04,190
而且您知道此Map功能对分配或
and you know this map function doesn't
know anything about distribution or

637
00:57:04,190 --> 00:57:07,970
多台计算机或我们需要的事实，我们需要跨网络移动数据
multiple computers or the fact we need
we need to move data across the network

638
00:57:07,970 --> 00:57:13,400
或谁知道这是非常简单的
or who knows what
this is extremely straightforward and

639
00:57:13,400 --> 00:57:21,890
减少单词数的reduce函数，用已知的方式调用记得
the reduce function for a word count the
reduce is called with you know remember

640
00:57:21,890 --> 00:57:25,430
每个reduce都会通过调用给定键的所有实例进行排序
each reduce is called with sort of all
the instances of a given key on the

641
00:57:25,430 --> 00:57:30,079
 MapReduce框架调用通过其负责的键以及一个
MapReduce framework calls reduce with
the key that it's responsible for and a

642
00:57:30,079 --> 00:57:38,390
映射产生的与该键关联的所有值的向量
vector of all the values that the maps
produced associated with that key the

643
00:57:38,390 --> 00:57:41,960
关键是这个词是所有值，我们在这里不喜欢它们，我们只是
key is the word the values are all ones
we don't like here about them we only

644
00:57:41,960 --> 00:57:47,420
关心它们的数量，因此reduce具有其自己的省略功能
care about how many they were and so
reduce has its own omit function that

645
00:57:47,420 --> 00:57:53,779
只是将要发出的值作为最终输出作为this的值
just takes a value to be emitted as the
final output as the value for the this

646
00:57:53,779 --> 00:58:01,789
关键，所以我们要承认这个数组的长度，所以这也大约是
key so we're gonna admit a length of
this array so this is also about as

647
00:58:01,789 --> 00:58:08,049
最简单的reduce函数具有，并且在Map Reduce中非常简单
simplest reduce functions have are and
in Map Reduce namely extremely simple

648
00:58:08,049 --> 00:58:15,859
并且不需要有关容错的知识或其他任何东西
and requiring no knowledge about fault
tolerance or anything else alright any

649
00:58:15,859 --> 00:58:20,529
有关基本框架的问题是
questions about the basic framework yes

650
00:58:27,390 --> 00:58:30,550
 [音乐] 
[Music]

651
00:58:36,099 --> 00:58:48,289
你的意思是你能提供减速器的输出吗？ 
you mean can you feed the output of the
reducers sort of oh yes oh yes in in in

652
00:58:48,289 --> 00:58:53,269
在现实生活中可以在现实生活中正常
in real life all right
in real life it is routine among

653
00:58:53,269 --> 00:58:58,219
您知道的MapReduce用户定义了一个MapReduce作业，该作业需要一些输入并
MapReduce users to you know define a
MapReduce job that took some inputs and

654
00:58:58,219 --> 00:59:01,969
产生一些输出，然后执行第二个MapReduce作业，您知道自己
produce some outputs and then have a
second MapReduce job you know you're

655
00:59:01,969 --> 00:59:08,899
做一些非常复杂的多阶段分析或迭代算法，例如
doing some very complicated multistage
analysis or iterative algorithm like

656
00:59:08,899 --> 00:59:13,119
例如PageRank，这是Google用于排序的算法
PageRank for example which is the
algorithm Google uses to sort of

657
00:59:13,119 --> 00:59:18,229
估算不同网页的重要性或影响力
estimate how important or influential
different webpages are that's an

658
00:59:18,229 --> 00:59:22,939
迭代算法是一种逐渐收敛于答案的算法，如果您
iterative algorithm is sort of gradually
converges on an answer and if you

659
00:59:22,939 --> 00:59:26,539
我认为他们最初是在MapReduce中实现的，您必须运行
implement in MapReduce which I think
they originally did you have to run the

660
00:59:26,539 --> 00:59:30,619
 MapReduce作业多次，并且每个作业的输出都是您所知道的
MapReduce job multiple times and the
output of each one is sort of you know

661
00:59:30,619 --> 00:59:36,649
网页列表，其中每个列表的值，权重或重要性都有更新
list of webpages with an updated sort of
value or weight or importance for each

662
00:59:36,649 --> 00:59:40,279
网页，因此通常将其输出然后用作输入
webpage so it was routine to take this
output and then use it as the input to

663
00:59:40,279 --> 00:59:56,029
另一个MapReduce工作哦，是的，您需要对这些东西进行设置
another MapReduce job oh yeah well yeah
you need to sort of set things up the

664
00:59:56,029 --> 00:59:59,269
输出，您需要对知识的简化功能进行评分
output you need to rate the reduced
function sort of in the knowledge that

665
00:59:59,269 --> 01:00:05,419
哦，我需要生成格式或所需信息的数据
oh I need to produce data that's in the
format or as the information required

666
01:00:05,419 --> 01:00:09,229
对于下一个MapReduce工作，我的意思是这实际上带来了
for the next MapReduce job I mean this
actually brings up a little bit of a

667
01:00:09,229 --> 01:00:16,309
 MapReduce框架的缺点，如果
shortcoming in the MapReduce framework
which is it's great if you are if the

668
01:00:16,309 --> 01:00:20,809
您需要运行的算法很容易表示为数学运算
algorithm you need to run is easily
expressible as a math followed by this

669
01:00:20,809 --> 01:00:26,179
按键排序数据，然后进行归约操作，仅此而已
sort of shuffling of the data by key
followed by a reduce and that's it

670
01:00:26,179 --> 01:00:30,589
我的MapReduce非常适合可以这种形式转换的算法， 
my MapReduce is fantastic for algorithms
that can be cast in that form and we're

671
01:00:30,589 --> 01:00:33,400
此外，每张Map都必须完全独立，并且
furthermore each of the maps has to be
completely independent and

672
01:00:33,400 --> 01:00:42,760
必须是纯功能性功能
are required to be functional pure
functional functions that just look at

673
01:00:42,760 --> 01:00:46,480
他们的论点，没有别的，你知道这就像一个限制
their arguments and nothing else
you know that's like it's a restriction

674
01:00:46,480 --> 01:00:49,990
事实证明，许多人想要运行更长的管道
and it turns out that many people want
to run much longer pipelines that

675
01:00:49,990 --> 01:00:53,170
涉及很多不同类型的处理，而MapReduce可以帮助您
involve lots and lots of different kinds
of processing and with MapReduce you

676
01:00:53,170 --> 01:00:58,390
必须将来自多个MapReduce的拼凑起来
have to sort of cobble that together
from multiple MapReduce distinct

677
01:00:58,390 --> 01:01:02,050
 MapReduce作业和更高级的系统，我们将在稍后的内容中进行讨论。 
MapReduce jobs and more advanced systems
which we will talk about later in the

678
01:01:02,050 --> 01:01:06,520
当然可以更好地让您指定完整的管道
course are much better at allowing you
to specify the complete pipeline of

679
01:01:06,520 --> 01:01:10,900
计算，它们会进行优化，您知道框架可以实现所有
computations and they'll do optimization
you know the framework realizes all the

680
01:01:10,900 --> 01:01:15,670
您要做的事情和组织更复杂的事情要有效地进行优化
stuff you have to do and organize much
more complicated efficiently optimize

681
01:01:15,670 --> 01:01:19,590
更复杂的计算
much more complicated computations

682
01:01:39,660 --> 01:01:44,080
从程序员的角度来看，这只是映射和减少
from the programmers point of view it's
just about map and reduce from our point

683
01:01:44,080 --> 01:01:49,320
的观点将是关于工作进程和工作服务器
of view it's going to be about the
worker processes and the worker servers

684
01:01:49,320 --> 01:01:55,390
它们是MapReduce框架的一部分，其中包括许多其他内容
that that are they're part of MapReduce
framework that among many other things

685
01:01:55,390 --> 01:02:01,930
调用Map并简化函数，所以从我们的角度来看，我们关心
call the map and reduce functions so
yeah from our point of view we care a

686
01:02:01,930 --> 01:02:06,190
关于周围框架如何组织的很多事情
lot about how this is organized by the
surrounding framework this is sort of

687
01:02:06,190 --> 01:02:14,340
程序员认为所有分发内容都被剥夺了
the programmers view with all the
distributive stuff stripped out yes

688
01:02:15,960 --> 01:02:32,170
抱歉，我要再说一遍哦，你的意思是即时数据在哪里可以
sorry I gotta say it again oh you mean
where does the immediate data go okay so

689
01:02:32,170 --> 01:02:38,020
有两个问题，一个是当您致电MIT时，数据发生了什么， 
there's two questions one is when you
call a MIT what happens to the data and

690
01:02:38,020 --> 01:02:42,330
另一个是功能运行的地方
the other is where the functions run so

691
01:02:46,910 --> 01:02:53,029
实际的答案是，首先烂掉的东西有很多说法
the actual answer is that first where
the stuff rotten there's a number of say

692
01:02:53,029 --> 01:02:58,190
一千台服务器，实际上这里要看的是图一
a thousand servers um actually the right
thing to look at here is figure one in

693
01:02:58,190 --> 01:03:04,430
在现实世界中，坐在这下面的纸有很多收藏
the paper sitting underneath this in the
real world there's some big collection

694
01:03:04,430 --> 01:03:12,410
服务器，我们称它们为工作服务器或工作服务器， 
of servers and we'll call them maybe
worker servers or workers and there's

695
01:03:12,410 --> 01:03:16,519
也是一个主服务器，用于组织整个计算和
also a single master server that's
organizing the whole computation and

696
01:03:16,519 --> 01:03:22,490
这里发生的是主服务器，知道知道有一些
what's going on here is the master
server for know knows that there's some

697
01:03:22,490 --> 01:03:27,799
您知道的输入文件数5000个输入文件
number of input files you know five
thousand input files and it farms out in

698
01:03:27,799 --> 01:03:30,890
将Map假期发送给其他工作人员，以便它将消息发送给
vacations of map to the different
workers so it'll send a message to

699
01:03:30,890 --> 01:03:37,759
工人七说请运行，您知道该Map功能
worker seven saying please run you know
this map function on such-and-such an

700
01:03:37,759 --> 01:03:43,400
输入文件，然后是worker函数，这是MapReduce的一部分， 
input file and then the worker function
which is you know part of MapReduce and

701
01:03:43,400 --> 01:03:50,089
完全了解Map Reduce，然后读取文件，读取输入内容
knows all about Map Reduce well then
read the file read the input whatever

702
01:03:50,089 --> 01:03:56,599
不论输入哪个文件，然后以文件名值作为参数调用此映射函数
whichever input file and call this map
function with the file name value as its

703
01:03:56,599 --> 01:04:02,750
论据，然后工人进程将雇员在其中实现什么， 
arguments then that worker process will
employees what implements in it and

704
01:04:02,750 --> 01:04:10,279
每次map调用发出工作进程时，都会将此数据写入文件中
every time the map calls emit the worker
process will write this data to files on

705
01:04:10,279 --> 01:04:17,420
本地磁盘，因此映射发生了什么，并且它们会在
the local disk so what happens to map
emits and is they produce files on the

706
01:04:17,420 --> 01:04:21,950
映射工作人员正在累积所有键和值的本地光盘
map workers local discs that are
accumulating all the keys and values

707
01:04:21,950 --> 01:04:30,200
由Map产生的结果在该工作程序上运行，因此在数学阶段结束时
produced by the maps run on that worker
so at the end of the math phase what

708
01:04:30,200 --> 01:04:35,089
我们剩下的是所有这些工人机器，它们的输出是
we're left with is all those worker
machines each of which has the output of

709
01:04:35,089 --> 01:04:42,369
一些在该工作机上运行的Map，然后是MapReduce 
some of whatever maps were run on that
worker machine then the MapReduce

710
01:04:42,369 --> 01:04:46,819
工作人员安排将数据移动到需要的位置
workers arrange to move the data to
where it's going to be needed for the

711
01:04:46,819 --> 01:04:53,240
减少这样的结果，因为在典型的大型计算中您知道这一点
reduces so and since and a you know in a
typical big computation you know this

712
01:04:53,240 --> 01:04:59,089
这种减少指示将需要所有的Map输出
this reduce indication is going to need
all map output that

713
01:04:59,089 --> 01:05:04,289
提到了钥匙a，但事实证明，这是一个简单的例子
mentioned the key a but it's gonna turn
out you know this is a simple example

714
01:05:04,289 --> 01:05:10,470
但可能通常每个Map指示都会产生很多
but probably in general every single map
indication will have produce lots of

715
01:05:10,470 --> 01:05:15,390
键，包括键a的某些实例，因此通常在我们什至还没有顺序之前
keys including some instances of key a
so typically in order before we can even

716
01:05:15,390 --> 01:05:20,190
运行作为MapReduce工作程序的MapReduce框架的reduce函数
run this reduce function the MapReduce
framework that is the MapReduce worker

717
01:05:20,190 --> 01:05:24,269
在我们千台服务器中运行的一台将不得不与每台服务器进行对话
running on one of our thousand servers
is going to have to go talk to every

718
01:05:24,269 --> 01:05:28,529
千台服务器中的另一台，说你知道我要运行
single other of the thousand servers and
say look you know I'm gonna run the

719
01:05:28,529 --> 01:05:33,210
减少密钥，请查看存储在您的
reduce for key a please look at the
intermediate map output stored in your

720
01:05:33,210 --> 01:05:38,160
磁盘并找出密钥a的所有实例，然后通过网络发送它们
disk and fish out all of the instances
of key a and send them over the network

721
01:05:38,160 --> 01:05:43,529
对我来说，reduce worker要做的就是从每个人那里获取
to me so the reduce worker is going to
do that it's going to fetch from every

722
01:05:43,529 --> 01:05:47,400
负责它负责的所有密钥实例
worker all of the instances of the key
that it's responsible for that the

723
01:05:47,400 --> 01:05:51,839
主人告诉它要负责，一旦收集到所有数据
master has told it to be responsible for
and once it's collected all of that data

724
01:05:51,839 --> 01:05:58,470
那么它可以调用reduce，而reduce函数本身调用reduce可以忽略
then it can call reduce and the reduce
function itself calls reduce omit which

725
01:05:58,470 --> 01:06:04,710
与其中的映射不同，减少辐射所做的是写输出
is different from the map in it and what
reduces emit does is writes the output

726
01:06:04,710 --> 01:06:14,519
到Google使用的群集文件服务中的文件，所以这是我
to a file in a cluster file service that
Google uses so here's something I

727
01:06:14,519 --> 01:06:21,329
没有提到我没有提到输入生活在哪里以及
haven't mentioned I haven't mentioned
where the input lives and where the

728
01:06:21,329 --> 01:06:28,799
输出生活都是文件，因为我们想要的任何输入
output lives they're both files because
any piece of input we want the

729
01:06:28,799 --> 01:06:34,589
能够读取任何工作服务器上任何输入的灵活性，这意味着
flexibility to be able to read any piece
of input on any worker server that means

730
01:06:34,589 --> 01:06:42,509
我们需要某种网络文件系统来存储输入数据，因此确实
we need some kind of network file system
to store the input data and so indeed

731
01:06:42,509 --> 01:06:50,160
本文讨论了称为GFS或Google文件系统的事物，而GFS是
the paper talks about this thing called
GFS or Google file system and GFS is a

732
01:06:50,160 --> 01:06:54,210
集群文件系统和BFS实际上在完全相同的一组工作器上运行
cluster file system and BFS actually
runs on exactly the same set of workers

733
01:06:54,210 --> 01:07:00,630
能够自动运行MapReduce和输入GFS的服务器
that work our servers that run MapReduce
and the input GFS just automatically

734
01:07:00,630 --> 01:07:03,839
当您知道这是一个文件系统时，您可以在我的文件中读取它
when you you know it's a file system you
can read in my files it just

735
01:07:03,839 --> 01:07:08,490
自动将您存储在其中的任何大文件拆分到许多服务器上， 
automatically splits up any big file you
store on it across lots of servers and

736
01:07:08,490 --> 01:07:14,360
 64 MB的块，因此如果您查看10 TB的已爬网内容，则进行写操作
64 megabyte chunks so if you write
if you view of ten terabytes of crawled

737
01:07:14,360 --> 01:07:20,120
网页内容，您只需将它们作为单个大文件写入GFS 
web page contents and you just write
them to GFS even as a single big file

738
01:07:20,120 --> 01:07:25,010
 GFS会自动将大量数据拆分为64 KB 
GFS will automatically split that vast
amount of data up into 64 kilobyte

739
01:07:25,010 --> 01:07:30,950
块均匀地分布在所有GFS服务器上，也就是说所有
chunks distributed evenly over all of
the GFS servers which is to say all the

740
01:07:30,950 --> 01:07:34,580
 Google提供的服务器，这真是太棒了
servers that Google has available and
that's fantastic that's just what we

741
01:07:34,580 --> 01:07:39,650
如果需要，然后我们要运行一个MapReduce作业，该作业将整个已爬网的网站
need if we then want to run a MapReduce
job that takes the entire crawled web as

742
01:07:39,650 --> 01:07:44,540
输入数据的存储方式已经在所有
input the data is already stored in a
way that split up evenly across all the

743
01:07:44,540 --> 01:07:49,940
服务器，这意味着您知道的Map工作人员将向您启动
servers and so that means that the map
workers you know we're gonna launch you

744
01:07:49,940 --> 01:07:53,000
知道我们是否有一千台服务器，每个服务器将启动一千名Map工作者
know if we have a thousand servers we're
gonna launch a thousand map workers each

745
01:07:53,000 --> 01:07:57,080
在输入数据上读取一个1000s，他们将能够读取
reading one 1000s at the input data and
they're going to be able to read the

746
01:07:57,080 --> 01:08:04,490
来自一千个GFS文件服务器的并行数据，因此变得越来越庞大
data in parallel from a thousand GFS
file servers thus getting now tremendous

747
01:08:04,490 --> 01:08:10,960
您知道的通读总吞吐量为一千台服务器
total read throughput you know the read
through put up a thousand servers

748
01:08:20,990 --> 01:08:25,470
所以您是否认为Google当中有一组物理机器
so so are you thinking maybe that Google
has one set of physical machines among

749
01:08:25,470 --> 01:08:40,490
 GFS和运行MapReduce作业的一组单独的物理机可以

750
01:08:40,580 --> 01:08:48,630
是的，所以问题是这里的箭头实际上涉及什么？ 
right so the question is what does this
arrow here actually involve and the

751
01:08:48,630 --> 01:08:51,630
回答说，实际上这些年来，随着Google 
answer that actually it sort of changed
over the years as Google's

752
01:08:51,630 --> 01:08:58,200
涉及这个系统，但是如果我们有
involve this system but you know what
this in those general case if we have

753
01:08:58,200 --> 01:09:02,880
大型文件存储在某些大型网络文件系统中，就像GFS一样
big files stored in some big Network
file system like you know it's like GFS

754
01:09:02,880 --> 01:09:07,229
有点像您可能在雅典娜上使用过的AFS，在那里您可以与
is a bit like AFS you might have used on
Athena where you go talk to some

755
01:09:07,229 --> 01:09:11,039
收集，然后将数据拆分到大收集o服务器上

756
01:09:11,040 --> 01:09:14,580
到网络上的那些服务器以在这种情况下检索您的数据
to those servers over the network to
retrieve your data in that case what

757
01:09:14,580 --> 01:09:20,520
此箭头可能表示Meta MapReduce worker进程必须关闭
this arrow might represent is the meta
MapReduce worker process has to go off

758
01:09:20,520 --> 01:09:25,800
并通过网络与正确的GFS服务器或可能与
and talk across the network to the
correct GFS server or maybe servers that

759
01:09:25,800 --> 01:09:30,950
存储它作为输入的一部分，并通过网络将其获取到MapReduce 
store it's part of the input and fetch
it over the network to the MapReduce

760
01:09:30,950 --> 01:09:35,310
工人机器才能通过Map，这当然是最通用的
worker machine in order to pass the map
and that's certainly the most general

761
01:09:35,310 --> 01:09:40,800
案例，这最终是MapReduce在世界上实际运作的方式
case and that was eventually how
MapReduce actually worked in the world

762
01:09:40,800 --> 01:09:45,930
但是如果您这样做的话，那将是很多网络
of this paper though and and if you did
that that's a lot of network

763
01:09:45,930 --> 01:09:49,350
交流中您正在谈论10 TB的数据，而我们已经移走了10 TB 
communication are you talking about ten
terabytes of data and we have moved 10

764
01:09:49,350 --> 01:09:54,270
 TB的数据中心网络（您知道数据中心） 
terabytes across their data center
network which you know data center

765
01:09:54,270 --> 01:09:57,780
网络每秒需要千兆比特，但移动数十万比特仍需要很多时间
networks wanting gigabits per second but
it's still a lot of time to move tens of

766
01:09:57,780 --> 01:10:04,170
兆兆字节的数据，以便尝试并确实在本文的世界中
terabytes of data in order to try to and
indeed in the world of this paper in

767
01:10:04,170 --> 01:10:08,850
 2004年，MapReduce系统中最受限制的瓶颈是网络
2004 the most constraining bottleneck in
their MapReduce system was Network

768
01:10:08,850 --> 01:10:13,590
吞吐量，因为它们在网络上运行，如果您可以阅读到
throughput because they were running on
a network if you sort of read as far as

769
01:10:13,590 --> 01:10:24,750
评估部分他们的网络他们的网络因为他们有成千上万
the evaluation section their network
their network as was they had thousands

770
01:10:24,750 --> 01:10:27,230
机器
of machines

771
01:10:27,479 --> 01:10:32,920
无论如何，他们会收集机器，他们会插入机器，你知道
whatever and they would collect machines
they would plug machines and you know

772
01:10:32,920 --> 01:10:36,519
每个机架的机器，您都知道该机架的以太网交换机或
each rack of machines and you know an
Ethernet switch for that rack or

773
01:10:36,519 --> 01:10:40,449
某事，但是然后您知道他们都需要互相交谈，但是有
something but then you know they all
need to talk to each other but there was

774
01:10:40,449 --> 01:10:45,519
与所有落基山脉都是与之通信的网络交换机的路由以太网交换机， 
a route Ethernet switch that all of the
Rockies are net switches talked to and

775
01:10:45,519 --> 01:10:51,039
这一点，您知道，所以如果您只选择一些Map Reduce工作人员和一些GFS 
this one and you know so if you just
pick some Map Reduce worker and some GFS

776
01:10:51,039 --> 01:10:54,880
服务器，您知道机会至少是之间通信时间的一半
server you know chances are at least
half the time the communication between

777
01:10:54,880 --> 01:10:58,409
他们必须通过这个不会改变他们的路线
them has to pass through this one
wouldn't switch their routes which had

778
01:10:58,409 --> 01:11:05,650
总吞吐量只有一些，我忘了你知道一些
only some amount of total throughput
which I forget you know some number of

779
01:11:05,650 --> 01:11:13,590
每秒千兆字节，我忘记了这个数字，但是当我进行除法运算时
gigabits per second and I forget the
number well but when I did the division

780
01:11:13,590 --> 01:11:19,119
被除以路由中可用的总吞吐量
that is divided up to the total
throughput available in the routes which

781
01:11:19,119 --> 01:11:23,769
他们在论文中使用的大约2000台服务器进行了实验
by the roughly 2000 servers that they
used in the papers experiments what I

782
01:11:23,769 --> 01:11:27,999
得到的是路由交换机或整个网络的每台机器共享
got was that each machine share of the
route switch or of the total network

783
01:11:27,999 --> 01:11:36,309
在其设置中，每秒50兆位的容量仅为每秒50兆位
capacity was only 50 megabits per second
per second in their setup 50 megabits

784
01:11:36,309 --> 01:11:43,090
每台机器每秒，然后看起来好像很多50兆位天哪
per second per machine and then might
seem like a lot 50 megabits gosh

785
01:11:43,090 --> 01:11:47,440
数百万，但与磁盘的速度相比实际上很小
millions and millions but it's actually
quite small compared to how fast a disks

786
01:11:47,440 --> 01:11:53,769
罗恩（Ron）或CPU在运行，因此其网络每秒50兆位的速度是
Ron or CPUs run and so this with their
network this 50 megabits per second was

787
01:11:53,769 --> 01:11:57,760
就像一个巨大的极限，所以他们真的站在
like a tremendous limit and so they
really stood on their heads in the

788
01:11:57,760 --> 01:12:02,979
论文中描述的设计避免使用网络，他们发挥了
design described in the paper to avoid
using the network and they played a

789
01:12:02,979 --> 01:12:07,059
避免在可能的情况下通过网络发送内容的一系列技巧
bunch of tricks to avoid sending stuff
over the network when they possibly

790
01:12:07,059 --> 01:12:14,380
可以避免它之一，就是他们将运行gfs服务器，并且
could avoid it one of them was they
would they ran the gfs servers and the

791
01:12:14,380 --> 01:12:19,059
 MapReduce工人在同一组机器上，因此他们有一千
MapReduce workers on the same set of
machines so they have a thousand

792
01:12:19,059 --> 01:12:25,090
运行GFS的计算机，他们在那千台上实现了GFS服务
machines they'd run GFS they implement
their GFS service on that thousand

793
01:12:25,090 --> 01:12:29,530
机器，然后在同一千台机器上运行MapReduce，然后
machines and run MapReduce on the same
thousand machines and then when the

794
01:12:29,530 --> 01:12:34,630
师父将Map工作拆分开来，然后将其耕种到不同的地方
master was splitting up the map work and
sort of farming it out to different

795
01:12:34,630 --> 01:12:41,550
当它要运行将要运行的Map时，会很聪明
workers it would cleverly when it was
about to run the map that was going to

796
01:12:41,550 --> 01:12:47,790
从输入文件中读取一个文件，它将从GFS找出哪个服务器实际持有
read from input file one it would figure
out from GFS which server actually holds

797
01:12:47,790 --> 01:12:53,070
输入文件一个在其本地磁盘上，它将发送该输入文件的映射
input file one on its local disk and it
would send the map for that input file

798
01:12:53,070 --> 01:12:59,190
到同一台计算机上的MapReduce软件，因此默认情况下，此箭头
to the MapReduce software on the same
machine so that by default this arrow

799
01:12:59,190 --> 01:13:03,450
实际上是从本地磁盘读取的本地本地，并且不涉及
was actually local local read from the
local disk and did not involve the

800
01:13:03,450 --> 01:13:07,290
网络，您会根据故障或负载或其他原因知道
network and you know depending on
failures or load or whatever that

801
01:13:07,290 --> 01:13:11,970
不能总是这样做，但是几乎所有Map都可以在同一Map上运行
couldn't always do that but almost all
the maps would be run on the very same

802
01:13:11,970 --> 01:13:17,400
机器并存储数据，从而为他们节省了大量时间
machine and stored the data thus saving
them vast amount of time that they would

803
01:13:17,400 --> 01:13:22,770
否则，必须等待下一个技巧才能在网络上移动输入数据
otherwise had to wait to move the input
data across the network the next trick

804
01:13:22,770 --> 01:13:28,470
他们玩过的Map就是我之前提到的Map，并将此输出存储在本地
they played is that map as I mentioned
before stores this output on the local

805
01:13:28,470 --> 01:13:31,860
您在其上运行Map的计算机的磁盘，以便再次存储
disk of the machine that you run the map
on so again storing the output of the

806
01:13:31,860 --> 01:13:35,480
Map不需要网络通讯，他不是立即
map does not require network
communication he's not immediately

807
01:13:35,480 --> 01:13:42,360
因为输出存储在磁盘中，但是我们肯定知道一种方法或
because the output stored in the disk
however we know for sure that one way or

808
01:13:42,360 --> 01:13:46,980
以便通过MapReduce的方式将所有您知道的人分组在一起
another in order to group together all
of you know by the way the MapReduce is

809
01:13:46,980 --> 01:13:51,510
定义以便将与给定关联的所有值组合在一起
defined in order to group together all
of the values associated with the given

810
01:13:51,510 --> 01:13:57,750
密钥并将它们传递给单个调用以在某台机器上进行生产
key and pass them to a single invocation
to produce on some machine this is going

811
01:13:57,750 --> 01:14:02,190
需要网络通信，我们将要知道我们需要获取
to require network communication we're
gonna you know we want to need to fetch

812
01:14:02,190 --> 01:14:05,970
所有托架，并给他们一台必须在
all bays and give them a single
machine that have to be moved across the

813
01:14:05,970 --> 01:14:11,690
网络，所以这种洗牌的运动是一种
network and so this shuffle this
movement of the keys from is kind of

814
01:14:11,690 --> 01:14:16,740
最初按行存储在运行Map的同一台机器上，我们需要它们
originally stored by row and on the same
machine that ran the map we need them

815
01:14:16,740 --> 01:14:19,800
本质上是将要存储在机器上的列上
essentially to be stored on by column on
the machine that's going to be

816
01:14:19,800 --> 01:14:23,610
负责减少行存储的这种转换
responsible for reduce this
transformation of row storage

817
01:14:23,610 --> 01:14:28,530
从本质上讲，列存储被称为纸质，称为洗牌，实际上
essentially column storage is called the
paper calls a shuffle and it really that

818
01:14:28,530 --> 01:14:33,000
需要从Map上跨网络移动所有数据， 
required moving every piece of data
across the network from the map that

819
01:14:33,000 --> 01:14:36,300
减少到需要它的程度，现在就像昂贵的
produced it to the reduce that would
need it and now it's like the expensive

820
01:14:36,300 --> 01:14:41,870
是MapReduce的一部分
part of the MapReduce yeah

821
01:14:51,840 --> 01:14:55,239
你是对的，你可以想象一个更不同的定义
you're right you can imagine a different
definition in which you have a more kind

822
01:14:55,239 --> 01:15:00,070
流减少我不知道我没有想到这一点
of streaming reduce I don't know I
haven't thought this through I don't

823
01:15:00,070 --> 01:15:04,239
知道为什么就程序员而言那是否可行
know why whether that would be feasible
or not certainly as far as programmer

824
01:15:04,239 --> 01:15:09,940
界面就像是他们的第一目标的目标是
interface like if the goal their
number-one goal really was to be able to

825
01:15:09,940 --> 01:15:13,989
那些不知道发生了什么的人可以很容易地进行编程
make it easy to program by people who
just had no idea of what was going on in

826
01:15:13,989 --> 01:15:18,460
系统，所以您可能知道这个斑点，这实际上是减少
the system so it may be that you know
this speck this is really the way reduce

827
01:15:18,460 --> 01:15:24,850
函数的外观，您在C ++或类似的流式版本中就知道了
functions look and you know in C++ or
something like a streaming version of

828
01:15:24,850 --> 01:15:30,190
现在开始看起来我不知道看起来如何可能不是这个
this is now starting to look I don't
know how it look probably not this

829
01:15:30,190 --> 01:15:35,320
符号，但您知道也许可以那样做，实际上许多现代
symbol but you know maybe it could be
done that way and indeed many modern

830
01:15:35,320 --> 01:15:41,530
系统人们对现代事物的了解变得更加复杂
systems people got a lot more
sophisticated with modern things that

831
01:15:41,530 --> 01:15:45,430
是MapReduce的后续产品，它们确实涉及处理
are the successors the MapReduce and
they do indeed involve processing

832
01:15:45,430 --> 01:15:50,739
数据流通常不是批量处理方法，而是批量处理
streams of data often rather than this
very batch approach there is a batch

833
01:15:50,739 --> 01:15:54,970
从某种意义上说，我们等待直到获得所有数据，然后进行处理
approach in the sense that we wait until
we get all the data and then we process

834
01:15:54,970 --> 01:15:59,670
因此首先必须要有一个有限输入的概念
it so first of all that you then have to
have a notion of finite inputs right

835
01:15:59,670 --> 01:16:05,980
现代系统通常确实可以让您流媒体，并且能够
modern systems often do indeed you
streams and and are able to take

836
01:16:05,980 --> 01:16:15,460
借助MapReduce可以提高效率，所以这就是重点
advantage of some efficiencies do that
MapReduce okay so this is the point at

837
01:16:15,460 --> 01:16:19,450
这是所有网络流量发生的地方，这可以
which this shuffle is where all the
network traffic happens this can

838
01:16:19,450 --> 01:16:23,920
实际上是海量数据，所以如果您考虑排序，那么就进行排序
actually be a vast amount of data so if
you think about sort if you're sorting

839
01:16:23,920 --> 01:16:29,440
排序输出的大小与排序输入的大小相同，因此
the the output of the sort has the same
size as the input to the sort so that

840
01:16:29,440 --> 01:16:32,890
表示如果您知道输入的数据量是10 TB， 
means that if you're you know if your
input is 10 terabytes of data and you're

841
01:16:32,890 --> 01:16:36,220
运行某种操作，您正在通过以下网络在网络上移动10 TB的数据
running a sort you're moving 10
terabytes of data across a network at

842
01:16:36,220 --> 01:16:40,780
这一点，您的输出也将是10 TB，所以这是很多
this point and your output will also be
10 terabytes and so this is quite a lot

843
01:16:40,780 --> 01:16:44,140
数据，然后确实来自任何MapReduce作业，尽管不是全部
of data and then indeed it is from any
MapReduce jobs although not all there's

844
01:16:44,140 --> 01:16:49,690
一些在这些阶段显着减少数据量的人
some that significantly reduce the
amount of data at these stages somebody

845
01:16:49,690 --> 01:16:52,900
提到了哦，如果您想将reduce的输出输入另一个
mentioned Oh what if you want to feed
the output of reduce into another

846
01:16:52,900 --> 01:16:56,979
 MapReduce工作确实是人们通常想要做的， 
MapReduce job and indeed that was often
what people wanted to do and

847
01:16:56,979 --> 01:17:00,400
如果reduce的输出可能像四类或网络一样巨大
in case the output of the reduce might
be enormous like four sort or web and

848
01:17:00,400 --> 01:17:05,260
在十TB的输入上混合生产的输出
mixing the output of the produces on ten
terabytes of input the output of the

849
01:17:05,260 --> 01:17:09,249
再次减少将为十兆字节，因此减少的输出也将被存储
reduces again gonna be ten terabytes so
the output of the reduce is also stored

850
01:17:09,249 --> 01:17:13,869
在GFS上，您知道的系统reduce只会生成这些密钥
on GFS and the system would you know
reduce would just produce these key

851
01:17:13,869 --> 01:17:20,320
值对，但MapReduce框架会收集它们并将其写入
value pairs but the MapReduce framework
would gather them up and write them into

852
01:17:20,320 --> 01:17:27,489
 GFS上的巨大文件，因此进行了另一轮网络通信
giant files on GFS and so there was
another round of network communication

853
01:17:27,489 --> 01:17:33,039
将每个reduce的输出传递到GFS服务器所需的
required to get the output of each
reduce to the GFS server that needed to

854
01:17:33,039 --> 01:17:37,959
存储减少的内容，因为您可能认为他们本可以玩
store that reduce and because you might
think that they could have played the

855
01:17:37,959 --> 01:17:42,489
与将输出存储在GFS服务器上的输出相同的技巧
same trick with the output of storing
the output on the GFS server that

856
01:17:42,489 --> 01:17:48,969
碰巧运行了运行Reduce的MapReduce工作者，也许他们做了
happened to run the MapReduce worker
that ran the reduce and maybe they did

857
01:17:48,969 --> 01:17:53,979
这样做是因为GFS以及拆分数据以提高性能
do that but because GFS as well as
splitting data for performance also

858
01:17:53,979 --> 01:17:58,030
保留两三份副本以进行容错，这意味着无论您做什么
keeps two or three copies for fault
tolerance that means no matter what you

859
01:17:58,030 --> 01:18:01,349
需要通过网络将数据的一个副本写入另一台服务器
need to write one copy of the data
across a network to a different server

860
01:18:01,349 --> 01:18:05,699
所以这里有很多网络通信，这里还有很多
so there's a lot of network
communication here and a bunch here also

861
01:18:05,699 --> 01:18:09,999
而正是这种网络通信确实限制了
and I was this network communication
that really limited the throughput in

862
01:18:09,999 --> 01:18:17,679
 MapReduce于2004年在2020年因为该网络
MapReduce
in 2004 in 2020 because this network

863
01:18:17,679 --> 01:18:21,789
安排是人们想要做的很多事情的限制因素
arrangement was such a limiting factor
for so many things people wanted to do

864
01:18:21,789 --> 01:18:26,079
在数据中心中，现代数据中心网络从根本上要快得多
in datacenters modern data center
networks are a lot faster at the root

865
01:18:26,079 --> 01:18:30,639
比以前要多，所以您可能知道一个典型的数据中心网络
than this was and so you know one
typical data center network you might

866
01:18:30,639 --> 01:18:34,329
看到今天实际上有很多根而不是单个根开关
see today actually has many root instead
of a single root switch that everything

867
01:18:34,329 --> 01:18:40,269
必须经历的过程中，您可能知道许多根交换机和每个机架
has to go through you might have you
know many root switches and each rack

868
01:18:40,269 --> 01:18:44,530
交换机与每种复制的根交换机都有连接，并且
switch has a connection to each of these
sort of replicated root switches and the

869
01:18:44,530 --> 01:18:48,599
流量在根交换机之间分配，因此现代数据中心网络
traffic is split up among the root
switches so modern data center networks

870
01:18:48,599 --> 01:18:54,880
具有更高的网络吞吐量，因此，我认为
have far more network throughput and
because of that actually modern I think

871
01:18:54,880 --> 01:19:00,309
 Google几年前就停止使用MapReduce，但是在他们停止之前
Google sort of stopped using MapReduce a
few years ago but before they stopped

872
01:19:00,309 --> 01:19:04,959
使用它，现代MapReduce实际上不再尝试在
using it the modern MapReduce actually
no longer tried to run the maps on the

873
01:19:04,959 --> 01:19:08,139
与存储数据的机器相同，他们很乐意对来自
same machine as the data stored on they
were happy to vote the data from

874
01:19:08,139 --> 01:19:16,439
在任何地方，因为他们只是认为这是非常快的，好的
anywhere because they just assumed that
was extremely fast okay we're out of

875
01:19:16,439 --> 01:19:21,689
 MapReduce的时间我们要在下一个年底结束
time for MapReduce
we have a lab due at the end of next

876
01:19:21,689 --> 01:19:24,840
一个星期，你会自己写一些
week
in which you'll write your own somewhat

877
01:19:24,840 --> 01:19:28,349
简化的MapReduce，所以可以玩得开心
simplified MapReduce so have fun with
that

878
01:19:28,349 --> 01:19:33,079
星期四见
and see you on Thursday

